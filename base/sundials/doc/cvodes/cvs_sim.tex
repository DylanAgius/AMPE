%%===================================================================================
\chapter{Using CVODES for IVP Solution}\label{s:simulation}
%%===================================================================================

This chapter is concerned with the use of {\cvodes} for the solution of
initial value problems (IVPs).  The following sections treat the header
files and the layout of the user's main program, and provide descriptions
of the {\cvodes} user-callable functions and user-supplied functions.

This usage is essentially equivalent to using {\cvode}~\cite{cvode2.4.0_ug}.
The listings of the sample programs in the companion document \cite{cvode2.4.0_ex} 
may also be helpful.  Those codes may be used as templates and are included 
in the {\cvodes} package.

The user should be aware that not all linear solver modules are compatible 
with all {\nvector} implementations. 
\index{CVODES@{\cvodes} linear solvers!NVECTOR@{\nvector} compatibility}
For example, {\nvecp} is not compatible with the direct dense or direct band 
linear solvers since these linear solver modules need to form the complete
system Jacobian. The following {\cvodes} modules can only be used with {\nvecs}:
{\cvdense}, {\cvband} and {\cvbandpre}. Also, the preconditioner module {\cvbbdpre}
can only be used with {\nvecp}. 

{\cvodes} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Chapter \ref{c:constants}.

%%==============================================================================
\section{Access to libraries and header files}\label{ss:file_access}
%%==============================================================================

At this point, it is assumed that the installation of {\cvodes},
following the procedure described in Chapter \ref{s:install}, has
been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
{\cvodes}.  The relevant library files are
\begin{itemize}
\item {\em libdir}\id{/libsundials\_cvodes.}{\em lib},
\item {\em libdir}\id{/libsundials\_nvec*.}{\em lib} (one or two files),
\end{itemize}
where the file extension .{\em lib} is typically \id{.so} for shared libraries
and \id{.a} for static libraries. The relevant header files are located in
the subdirectories
\begin{itemize}
\item {\em incdir}\id{/include}
\item {\em incdir}\id{/include/cvodes}
\item {\em incdir}\id{/include/sundials}
\end{itemize}
The directories {\em libdir} and {\em incdir} are the install libray and include
directories. For a default installation, these are {\em builddir}\id{/lib} and
{\em builddir}\id{/include}, respectively, where {\em builddir} was defined in
Chapter \ref{s:install}.

Note that an application cannot link to both the {\cvode} and {\cvodes} libraries
because both contain user-callable functions with the same names (to ensure that {\cvodes}
is backward compatible with {\cvode}). Therefore, applications that contain both
IVP problems and IVPs with sensitivity analysis, should use {\cvodes}.

%%===================================================================================
\section{Data Types}\label{s:types}
%%===================================================================================
\input{types}

%%===================================================================================
\section{Header files}\label{ss:header_sim}
%%===================================================================================
\index{header files}
The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%%
\begin{itemize}
\item  \Id{cvodes.h}, 
  the main header file for {\cvodes}, which defines the several
  types and various constants, and includes function prototypes.
\end{itemize}
%%
Note that \id{cvodes.h} includes \Id{sundials\_types.h}, 
which defines the types \id{realtype} and \id{booleantype}
and the constants \id{FALSE} and \id{TRUE}.

The calling program must also include an {\nvector} implementation header file
(see \S\ref{s:nvector} for details).
For the two {\nvector} implementations that are included in the {\cvodes} package,
the corresponding header files are:
%%
\begin{itemize}
\item \Id{nvector\_serial.h}, 
  which defines the serial implementation {\nvecs};
\item \Id{nvector\_parallel.h}, 
  which defines the parallel ({\mpi}) implementation, {\nvecp}.
\end{itemize}
%%
Note that both these files in turn include the header file \Id{sundials\_nvector.h} which 
defines the abstract \Id{N\_Vector} data type. 

Finally, if the user chooses Newton iteration for the solution of the nonlinear
systems, then a linear solver module header file will be required. 
\index{CVODES@{\cvodes} linear solvers!header files}
The header files corresponding to the various linear solvers availble for use
with {\cvodes} are:
%%
\begin{itemize}
\item \Id{cvodes\_dense.h}, 
  which is used with the dense direct linear solver in 
  the context of {\cvodes}. This in turn includes a header file (\id{sundials\_dense.h})
  which defines the \Id{DenseMat} type and corresponding accessor macros; 
\item \Id{cvodes\_band.h}, 
  which is used with the band direct linear solver in the
  context of {\cvodes}. This in turn includes a header file (\id{sundials\_band.h})
  which defines the \Id{BandMat} type and corresponding accessor macros;
\item \Id{cvodes\_diag.h}, which is used with the diagonal linear solver in the
  context of {\cvodes};
\item \Id{cvodes\_spgmr.h}, 
  which is used with the Krylov solver {\spgmr} in the
  context of {\cvodes};
\item \Id{cvodes\_spbcgs.h}, 
  which is used with the Krylov solver {\spbcg} in the
  context of {\cvodes};
\item \Id{cvodes\_sptfqmr.h}; 
  which is used with the Krylov solver {\sptfqmr} in the
  context of {\cvodes};
\end{itemize}

The header files for the Krylov iterative solvers include \id{cvodes\_spils.h}
which defined common fuunctions and which in turn includes a header file (\id{sundials\_iterative.h})
which enumerates the kind of preconditioning and for the choices for the Gram-Schmidt process for {\spgmr}.

Other headers may be needed, depending upon the choice of
preconditioner, etc. In one of the examples in \cite{cvodes2.3.0_ex},
preconditioning is done with a block-diagonal matrix. For this, the
header \id{sundials\_smalldense.h} is included.

%%===================================================================================
\section{A skeleton of the user's main program}\label{ss:skeleton_sim}
%%===================================================================================

The following is a skeleton of the user's main program (or calling
program) for the integration of an ODE IVP. Some steps are independent
of the {\nvector} implementation used; where this is not the case,
usage specifications are given for the two implementations provided
with {\cvodes}: steps marked with {\p} correspond to {\nvecp}, while
steps marked with {\s} correspond to {\nvecs}.
\index{User main program!IVP solution}
\begin{Steps}
  
\item 
  {\bf {\p} Initialize MPI}

  Call \id{MPI\_Init(\&argc, \&argv);} to initialize {\mpi} if used by
  the user's program. Here \id{argc} and \id{argv} are the command line
  argument counter and array received by \id{main}, respectively.
  
\item
  {\bf Set problem dimensions}

  {\s} Set \id{N}, the problem size $N$.

  {\p} Set \id{Nlocal}, the local vector length (the sub-vector
  length for this process); \id{N}, the global vector length (the
  problem size $N$, and the sum of all the values of \id{Nlocal});
  and the active set of processes.
  
\item
  {\bf Set vector of initial values}
 
  To set the vector \id{y0} of initial values, use the appropriate functions defined by a
  particular {\nvector} implementation.  If a \id{realtype} array \id{ydata}
  containing the initial values of $y$ already exists, then make the call:

  {\s} \id{y0 = N\_VMake\_Serial(N, ydata);}

  {\p} \id{y0 = N\_VMake\_Parallel(comm, Nlocal, N, ydata);}

  Otherwise, make the call:

  {\s} \id{y0 = N\_VNew\_Serial(N);}

  {\p} \id{y0 = N\_VNew\_Parallel(comm, Nlocal, N);}

  and load initial values into the structure defined by:

  {\s} \id{NV\_DATA\_S(y0)}

  {\p} \id{NV\_DATA\_P(y0)}

  Here \id{comm} is the {\mpi} communicator, set in one of two ways: 
  If a proper subset of active processes is to be used, \id{comm} 
  must be set by suitable {\mpi} calls. Otherwise, to specify that all 
  processes are to be used, \id{comm} must be \id{MPI\_COMM\_WORLD}.
  
\item\label{i:cvode_create} 
  {\bf Create {\cvodes} object}

  Call \id{cvode\_mem = }\id{CVodeCreate}\id{(lmm, iter);} 
  to create the {\cvodes} memory block and to specify the solution method
  (linear multistep method and nonlinear solver iteration type).
  \id{CVodeCreate} returns a pointer to the {\cvodes} memory structure.
  See \S\ref{sss:cvodemalloc} for details.

\item\label{i:cvode_malloc} 
  {\bf Allocate internal memory}

  Call \id{CVodeMalloc}\id{(...);} 
  to provide required problem specifications,
  allocate internal memory for {\cvodes}, 
  and initialize {\cvodes}.
  \id{CVodeMalloc} returns a flag, the value of which indicates either success or an illegal
  argument value.  See \S\ref{sss:cvodemalloc} for details.
  
\item
  {\bf Set optional inputs}

  Call \id{CVodeSet*} functions to change any
  optional inputs that control the behavior of {\cvodes} from their default values.
  See \S\ref{sss:optin_main} for details.

\item\label{i:lin_solver} 
  {\bf Attach linear solver module}

  If Newton iteration is chosen, initialize the linear solver module
  with one of the following calls (for details see \S\ref{sss:lin_solv_init}):

  {\s} \id{ier = }\Id{CVDense}\id{(...);}

  {\s} \id{ier = }\Id{CVBand}\id{(...);}

  \id{ier = }\Id{CVDiag}\id{(...);}

  \id{ier = }\Id{CVSpgmr}\id{(...);}
  
  \id{ier = }\Id{CVSpbcg}\id{(...);}
  
  \id{ier = }\Id{CVSptfqmr}\id{(...);}
  
\item
  {\bf Set linear solver optional inputs}

  Call \id{CV*Set*} functions from the selected linear solver module to
  change optional inputs specific to that linear solver.
  See \S\ref{ss:optional_input} for details.

\item
  {\bf Specify rootfinding problem}
  \index{Rootfinding}

  Optionally, call \id{CVodeRootInit} to initialize a rootfinding problem
  to be solved during the integration of the ODE system.
  See \S\ref{ss:root_uc} for details.

\item
  {\bf Advance solution in time}

  For each point at which output is desired, call
  \id{ier = }\Id{CVode}\id{(cvode\_mem, tout, yout, \&tret, itask);}
  Set \Id{itask} to specify the return mode.
  The vector \id{y} (which can be the same as
  the vector \id{y0} above) will contain $y(t)$.
  See \S\ref{sss:cvode} for details.
  
\item
  {\bf Get optional outputs}

  Call \id{CV*Get*} functions to obtain optional output.
  See \S\ref{ss:optional_output} and \S\ref{ss:root_uc} for details.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the integration, deallocate memory for the vector \id{y}
  by calling the destructor function defined by the {\nvector} implementation:

  {\s} \id{N\_VDestroy\_Serial(y);}

  {\p} \id{N\_VDestroy\_Parallel(y);}
  
\item
  {\bf Free solver memory}

  Call \Id{CVodeFree}\id{(\&cvode\_mem);} to free the memory allocated for {\cvodes}.
  
\item 
  {\bf {\p} Finalize MPI}

  Call \id{MPI\_Finalize();} to terminate MPI.
  
\end{Steps}

%%===================================================================================
\section{User-callable functions for IVP solution}
\label{ss:cvodes_fct_sim}
%%===================================================================================

This section describes the {\cvodes} functions that are called by the
user to setup and then solve an IVP. Some of these are required. However,
starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of {\cvodes}. In any case, refer to
\S\ref{ss:skeleton_sim} for the correct order of these calls.
Calls related to rootfinding are described in \S\ref{s:using_rootfinding}.

%%==============================================================================
\subsection{CVODES initialization and deallocation functions}
\label{sss:cvodemalloc}
%%==============================================================================

The following three functions must be called in the order listed. The last one
is to be called only after the IVP solution is complete, as it frees the
{\cvodes} memory block created and allocated by the first two calls.
%%
\ucfunction{CVodeCreate}
{
  cvode\_mem = CVodeCreate(lmm, iter);
}
{
  The function \Id{CVodeCreate} instantiates a {\cvodes} solver object and
  specifies the solution method.
}
{
  \begin{args}[iter]
  \item[lmm] (\id{int})
    specifies the linear multistep method and may be one of two
    possible values: \Id{CV\_ADAMS} or \Id{CV\_BDF}.     
  \item[iter] (\id{int})
    specifies the type of nonlinear solver iteration and may be
    either \Id{CV\_NEWTON} or \Id{CV\_FUNCTIONAL}. 
  \end{args}
  The recommended choices for (\Id{lmm}, \Id{iter}) are
  (\id{CV\_ADAMS}, \id{CV\_FUNCTIONAL}) for nonstiff problems and
  (\id{CV\_BDF}, \id{CV\_NEWTON}) for stiff problems.
}
{
  If successful, \id{CVodeCreate} returns a pointer to the newly created 
  {\cvodes} memory block (of type \id{void *}).
  If an error occurred, \id{CVodeCreate} prints an error message to \id{stderr}
  and returns \id{NULL}.
}
{}
%%
%%
\ucfunction{CVodeMalloc}
{
flag = CVodeMalloc(cvode\_mem, f, t0, y0, itol, reltol, abstol);
}
{
  The function \Id{CVodeMalloc} provides required problem and solution
  specifications, allocates internal memory, and initializes {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[f] (\Id{CVRhsFn})
    is the {\C} function which computes $f$ in the ODE. This function has the 
    form \id{f(t, y, ydot, f\_data)} (for full details see \S\ref{ss:rhsFn}).
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$. 
  \item[itol] (\id{int}) 
    is one of \Id{CV\_SS}, \Id{CV\_SV}, or \Id{CV\_WF}. Here \Id{itol} = \id{SS}
    indicates scalar relative error tolerance and scalar absolute error tolerance,
    while \id{itol} = \id{CV\_SV} indicates scalar relative error tolerance and
    vector absolute error tolerance.  The latter choice is important when the
    absolute error tolerance needs to be different for each component of the ODE. 
    If \id{itol} = \id{CV\_WF}, the arguments \id{reltol} and \id{abstol} are
    ignored and the user is expected to provide a function to evaluate the error
    weight vector $W$, replacing (\ref{e:errwt}). See \id{CVodeSetEwtFn} in
    \S\ref{sss:optin_main}.
  \item[reltol] (\id{realtype})
    \index{tolerances}
    is the relative error tolerance.
  \item[abstol] (\id{void *})
    is a pointer to the absolute error tolerance. If \id{itol} = \id{CV\_SS},
    \id{abstol} must be a pointer to a \id{realtype} variable. If
    \id{itol} = \id{CV\_SV}, \id{abstol} must be an \id{N\_Vector} variable.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeMalloc} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a previous call
    to \id{CVodeCreate}.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}] 
    An input argument to \id{CVodeMalloc} has an illegal value.
  \end{args}
}
{
  See also \S\ref{sss:tol_advice} for advice on tolerances.

  The tolerance values in \id{reltol} and \id{abstol} may be changed between
  calls to \id{CVode} (see \id{CVodeSetTolerances} in \S\ref{sss:optin_main}).

  {\warn}It is the user's responsibility to provide compatible \id{itol} and
  \id{abstol} arguments.

  If an error occurred, \id{CVodeMalloc} also sends an error message to the
  error handler function.
}
%%
%%
\ucfunction{CVodeFree}
{
  CVodeFree(\&cvode\_mem);
}
{
  The function \Id{CVodeFree} frees the memory allocated by
  a previous call to \id{CVodeMalloc}.
}
{
  The argument is the pointer to the {\cvodes} memory block (of type \id{void *}).
}
{
  The function \id{CVodeFree} has no return value.
}
{}


%%==============================================================================
\subsection{Advice on choice and use of tolerances}\label{sss:tol_advice}
%%==============================================================================

\index{tolerances}
{\bf General advice on choice of tolerances.}
For many users, the appropriate choices for tolerance values in
\id{reltol} and \id{abstol} are a concern.  The following pieces of
advice are relevant.

(1) The scalar relative tolerance \id{reltol} is to be set to control relative
errors.  So \id{reltol} = 1.0E-4 means that errors are controlled to .01\%.  We
do not recommend using \id{reltol} larger than 1.0E-3.  On the other hand,
\id{reltol} should not be so small that it is comparable to the unit roundoff
of the machine arithmetic (generally around 1.0E-15).

(2) The absolute tolerances \id{abstol} (whether scalar or vector) need to
be set to control absolute errors when any components of the solution
vector \id{y} may be so small that pure relative error control is
meaningless.  For example, if \id{y[i]} starts at some nonzero value, but in time
decays to zero, then pure relative error control on \id{y[i]} makes no sense
(and is overly costly) after \id{y[i]} is below some noise level.  Then
\id{abstol} (if scalar) or \id{abstol[i]} (if a vector) needs to be set to that
noise level.  If the different components have different noise levels,
then \id{abstol} should be a vector.  See the example \id{cvsdenx} in the
{\cvode} package, and the discussion of it in the {\cvode} Examples document
\cite{cvode2.4.0_ex}.
In that problem, the three components vary betwen 0 and 1, and have
different noise levels; hence the \id{abstol} vector.  It is impossible to
give any general advice on \id{abstol} values, because the appropriate noise
levels are completely problem-dependent.  The user or modeler hopefully has
some idea as to what those noise levels are.

(3) Finally, it is important to pick all the tolerance values conservately,
because they control the error committed on each individual time step.
The final (global) errors are some sort of accumulation of those
per-step errors.  A good rule of thumb is to reduce the tolerances by a
factor of .01 from the actual desired limits on errors.  So if you
want .01\% accuracy (globally), a good choice is \id{reltol} = 1.0E-6.
But in any case, it is a good idea to do a few experiments with
the tolerances to see how the computed solution values vary as
tolerances are reduced.

\vspace{0.1in}
\index{tolerances}
{\bf Advice on controlling unphysical negative values.}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the numerical
solution, however, small negative (hence unphysical) values can then
occur.  In most cases, these values are harmless, and simply need to
be controlled, not eliminated. The following pieces of advice are relevant.

(1) The way to control the size of unwanted negative computed values
is with tighter absolute tolerances.  Again this requires some
knowledge of the noise level of these components, which may or may not
be different for different components.  Some experimentation may be
needed.

(2) If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of avoiding
a long explanation of them, if nothing else), then eliminate them, but
only in the context of the output medium.  Then the internal values carried
by the solver are unaffected.  Remember that a small negative value in \id{y}
returned by {\cvodes}, with magnitude comparable to \id{abstol} or less,
is equivalent to zero as far as the computation is concerned.

(3) The user's right-hand side routine \id{f} should never change a
negative value in the solution vector \id{y} to a non-negative value,
as a "solution" to this problem.  This can cause instability.  If the
\id{f} routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log of it), then the offending value should
be changed to zero or a tiny positive number in a temporary variable
(not in the input \id{y} vector) for the purposes of computing $f(t,y)$.


%%
%%==============================================================================
\subsection{Linear solver specification functions}\label{sss:lin_solv_init}
%%==============================================================================

As previously explained, Newton iteration requires the solution of
linear systems of the form (\ref{e:Newton}).  There are six {\cvodes} linear
solvers currently available for this task: {\cvdense}, {\cvband}, {\cvdiag},
{\cvspgmr}, {\cvspbcg}, and {\cvsptfqmr}.  The first three are direct solvers
and their names indicate the type of approximation used for the Jacobian 
$J = \partial{f}/\partial{y}$; {\cvdense}, {\cvband}, and {\cvdiag} work with
dense, banded, and diagonal approximations to $J$, respectively.  The last
three {\cvodes} linear solvers --- {\cvspgmr}, {\cvspbcg}, and {\cvsptfqmr} ---
are Krylov iterative solvers, which use scaled preconditioned GMRES, scaled
preconditioned Bi-CGStab, and scaled preconditioned TFQMR, respectively.
Together, they are refered to as {\cvspils} (from scaled preconditioned 
iterative linear solvers).

With any of the Krylov methods, preconditioning can be done on the left only, 
on the right only, on both the left and the right, or not at all. 
For the specification of a preconditioner, see the iterative linear solver sections 
in \S\ref{ss:optional_input} and \S\ref{ss:user_fct_sim}.

If preconditioning is done, user-supplied functions define left and right 
preconditioner matrices $P_1$ and $P_2$ (either of which could be the identity
matrix), such that the product $P_1 P_2$ approximates the Newton matrix
$M = I - \gamma J$ of (\ref{e:Newtonmat}).

\index{CVODES@{\cvodes} linear solvers!selecting one|(}
To specify a {\cvodes} linear solver, after the call to \id{CVodeCreate}
but before any calls to \id{CVode}, the user's program must call one
of the functions \Id{CVDense}, \Id{CVBand}, \Id{CVDiag}, \Id{CVSpgmr},
\Id{CVSpbcg}, or \Id{CVSptfqmr}, as documented below.
The first argument passed to these functions is the {\cvodes}
memory pointer returned by \id{CVodeCreate}.  A call to one of these
functions links the main {\cvodes} integrator to a linear solver and
allows the user to specify parameters which are specific to a
particular solver, such as the half-bandwidths in the {\cvband} case.
%%
The use of each of the linear solvers involves certain constants and possibly 
some macros, that are likely to be needed in the user code.  These are
available in the corresponding header file associated with the linear
solver, as specified below.
\index{CVODES@{\cvodes} linear solvers!selecting one|)}

\index{CVODES@{\cvodes} linear solvers!built on generic solvers|(} 
In each case except the diagonal approximation case {\cvdiag}, the linear
solver module used by {\cvodes} is actually built on top of a generic
linear system solver, which may be of interest in itself.  These generic
solvers, denoted {\dense}, {\band}, {\spgmr}, {\spbcg}, and {\sptfqmr},
are described separately in Chapter \ref{s:gen_linsolv}.
\index{CVODES@{\cvodes} linear solvers!built on generic solvers|)}

\index{CVODES@{\cvodes} linear solvers!CVDENSE@{\cvdense}}
\index{CVDENSE@{\cvdense} linear solver!selection of}
\index{CVDENSE@{\cvdense} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{CVDense}
{
  flag = CVDense(cvode\_mem, N);
}
{
  The function \Id{CVDense} selects the {\cvdense} linear solver. 

  The user's main program must include the \id{cvodes\_dense.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDENSE\_ILL\_INPUT]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The {\cvdense} initialization was successful.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_ILL\_INPUT}]
    The {\cvdense} solver is not compatible with the current {\nvector} module.
  \item[\Id{CVDENSE\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvdense} linear solver may not be compatible with a particular
  implementation of the {\nvector} module. 
  Of the two {\nvector} modules provided with {\sundials}, only {\nvecs} is 
  compatible.
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solvers!CVBAND@{\cvband}}
\index{CVBAND@{\cvband} linear solver!selection of}
\index{CVBAND@{\cvband} linear solver!NVECTOR@{\nvector} compatibility}
\index{half-bandwidths}
\ucfunction{CVBand}
{
  flag = CVBand(cvode\_mem, N, mupper, mlower);
}
{
  The function \Id{CVBand} selects the {\cvband} linear solver. 

  The user's main program must include the \id{cvodes\_band.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \item[mupper] (\id{long int})
    upper half-bandwidth of the problem Jacobian (or of the approximation of it).
  \item[mlower] (\id{long int})
    lower half-bandwidth of the problem Jacobian (or of the approximation of it).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBAND\_ILL\_INPUT]
  \item[\Id{CVBAND\_SUCCESS}] 
    The {\cvband} initialization was successful.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_ILL\_INPUT}]
    The {\cvband} solver is not compatible with the current {\nvector} module, or
    one of the Jacobian half-bandwidths is outside of its valid range
    ($0 \ldots$ \id{N}$-1$).
  \item[\Id{CVBAND\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvband} linear solver may not be compatible with a particular
  implementation of the {\nvector} module. Of the two {\nvector} modules 
  provided with {\sundials}, only {\nvecs} is compatible.
  The half-bandwidths are to be set such that the nonzero locations $(i,j)$ in the
  banded (approximate) Jacobian satisfy $-$\id{mlower} $\leq j-i \leq$ \id{mupper}.
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solvers!CVDIAG@{\cvdiag}}
\index{CVDIAG@{\cvdiag} linear solver!selection of}
\index{CVDIAG@{\cvdiag} linear solver!Jacobian approximation used by}
\index{Jacobian approximation function!diagonal!difference quotient}
\ucfunction{CVDiag}
{
  flag = CVDiag(cvode\_mem);
}
{
  The function \Id{CVDiag} selects the {\cvdiag} linear solver. 

  The user's main function must include the \id{cvodes\_diag.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDIAG\_ILL\_INPUT]
  \item[\Id{CVDIAG\_SUCCESS}]
    The {\cvdiag} initialization was successful.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_ILL\_INPUT}]
    The {\cvdiag} solver is not compatible with the current {\nvector} module.
  \item[\Id{CVDIAG\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvdiag} solver is the simplest of all of the current {\cvodes} linear solvers. 
  The {\cvdiag} solver uses an approximate diagonal Jacobian formed by way of a
  difference quotient. The user does {\em not} have the option of supplying a
  function to compute an approximate diagonal Jacobian.
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solvers!CVSPGMR@{\cvspgmr}}
\index{CVSPGMR@{\cvspgmr} linear solver!selection of} 
\ucfunction{CVSpgmr}
{
  flag = CVSpgmr(cvode\_mem, pretype, maxl);
}
{
  The function \Id{CVSpgmr} selects the {\cvspgmr} linear solver. 

  The user's main function must include the \id{cvodes\_spgmr.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    specifies the preconditioning type and must be one of: 
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL = 5}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspgmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvspgmr} solver uses a scaled preconditioned GMRES\index{GMRES method}
  iterative method to solve the linear system (\ref{e:Newton}).
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solvers!CVSPBCG@{\cvspbcg}}
\index{CVSPBCG@{\cvspbcg} linear solver!selection of} 
\ucfunction{CVSpbcg}
{
  flag = CVSpbcg(cvode\_mem, pretype, maxl);
}
{
  The function \Id{CVSpbcg} selects the {\cvspbcg} linear solver. 

  The user's main function must include the \id{cvodes\_spbcgs.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    specifies the preconditioning type and must be one of: 
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspbcg} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvspbcg} solver uses a scaled preconditioned Bi-CGStab
  \index{Bi-CGStab method}
  iterative method to solve the linear system (\ref{e:Newton}).
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solvers!CVSPTFQMR@{\cvsptfqmr}}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!selection of} 
\ucfunction{CVSptfqmr}
{
  flag = CVSptfqmr(cvode\_mem, pretype, maxl);
}
{
  The function \Id{CVSptfqmr} selects the {\cvsptfqmr} linear solver. 

  The user's main function must include the \id{cvodes\_sptfqmr.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    specifies the preconditioning type and must be one of: 
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvsptfqmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvsptfqmr} solver uses a scaled preconditioned TFQMR
  \index{TFQMR method}
  iterative method to solve the linear system (\ref{e:Newton}).
}


%%==============================================================================
\subsection{CVODE solver function}\label{sss:cvode}
%%==============================================================================

This is the central step in the solution process - the call to
perform the integration of the IVP.
%
\ucfunction{CVode}
{
  flag = CVode(cvode\_mem, tout, yout, tret, itask);
}
{
  The function \Id{CVode} integrates the ODE over an interval in $t$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[yout] (\id{N\_Vector})
    the computed solution vector.
  \item[tret] (\id{realtype *})
    the time reached by the solver.
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}|textbf}
    \index{output mode}
    a flag indicating the job of the solver for the next user step. 
    The \Id{CV\_NORMAL} option causes the solver to take internal steps until   
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $y($\id{tout}$)$. 
    The \Id{CV\_ONE\_STEP} option tells the solver to take just one internal step  
    and then return the solution at the point reached by that step. 
    The \Id{CV\_NORMAL\_TSTOP} and \Id{CV\_ONE\_STEP\_TSTOP} modes are     
    similar to \id{CV\_NORMAL} and \id{CV\_ONE\_STEP}, respectively, except    
    that the integration never proceeds past the value      
    \id{tstop} (specified through the function \id{CVodeSetStopTime}).
  \end{args}
}
{
  On return, \id{CVode} returns a vector \id{yout} and a corresponding 
  independent variable value $t=$\id{*tret}, such that \id{yout} is the computed 
  value of $y(t)$.

  In \id{CV\_NORMAL} mode (with no errors), \id{*tret} will be equal to \id{tout} 
  and \id{yout} = $y($\id{tout}$)$.

  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVode} succeeded and no roots were found.
  \item[\Id{CV\_TSTOP\_RETURN}]
    \id{CVode} succeeded by reaching the stopping point specified through
    the optional input function \id{CVodeSetStopTime} (see \S\ref{sss:optin_main}).
  \item[\Id{CV\_ROOT\_RETURN}]
    \id{CVode} succeeded and found one or more roots.  If \id{nrtfn}
     $>1$, call \id{CVodeGetRootInfo} to see which $g_i$ were found to
     have a root.  See \S\ref{s:using_rootfinding} for more information.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CV\_NO\_MALLOC}]
    The {\cvodes} memory was not allocated by a call to \id{CVodeMalloc}.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVode} is illegal. This includes the situation where
    a root of one of the root functions was found both at a point $t$ and also
    very near $t$.  It also includes the situation 
    where a component of the error weight vector becomes negative during internal 
    time-stepping. The \id{CV\_ILL\_INPUT} flag will also be returned if the linear 
    solver initialization function (called by the user after calling 
    \id{CVodeCreate}) failed to set the linear solver-specific \id{lsolve} field
    in \id{cvode\_mem}.
    In any case, the user should see the error message for details.
  \item[\Id{CV\_TOO\_CLOSE}]
    The initial time $t_0$ and the final time $t_{out}$ are too close to each 
    other and the user did not specify an initial step size.
  \item[\Id{CV\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but still could not reach tout. 
    The default value for \id{mxstep} is \id{MXSTEP\_DEFAULT = 500}.
  \item[\Id{CV\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Either error test failures occurred too many times (\id{MXNEF = 7}) during one 
    internal time step, or with $|h| = h_{min}$.
  \item[\Id{CV\_CONV\_FAILURE}] 
    Either convergence test failures occurred too many times (\id{MXNCF = 10}) during 
    one internal time step, or with $|h| = h_{min}$.             
  \item[\Id{CV\_LINIT\_FAIL}] 
    The linear solver's initialization function failed. 
  \item[\Id{CV\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_RHSFUNC\_FAIL}] 
    The right-hand side function failed in an unrecoverable manner.
  \item[\Id{CV\_FIRST\_RHSFUNC\_FAIL}] 
    The right-hand side function had a recoverable error at the first call.
  \item[\Id{CV\_REPTD\_RHSFUNC\_ERR}]
    Convergence tests occurred too many times due to repeated recoverable errors in
    the right-hand side function. The \id{CV\_REPTD\_RHSFUNC\_ERR} will also
    be returned if the right-hand side function had repeated recoverable errors
    during the estimation of an initial step size.
  \item[\Id{CV\_UNREC\_RHSFUNC\_ERR}]
    The right-hand function had a recoverable error, but no recovery was possible.
    This failure mode is rare, as it can occur only if the right-hand side function
    fails recoverably after an error test failed while at order one.
  \item[\Id{CV\_RTFUNC\_FAIL}] 
    The rootfinding function failed.
  \end{args} 
}
{
  The vector \id{yout} can occupy the same space as the \id{y0} vector of 
  initial conditions that was passed to \id{CVodeMalloc}. 

  In the \id{CV\_ONE\_STEP} mode, \id{tout} is only used on the first call
  to get the direction and a rough scale of the independent variable.

  All failure return values are negative and so the test \id{ier < 0}
  will trap all \id{CVode} failures.

  On any error return in which one or more internal steps were taken by
  \id{CVode}, the returned values of \id{tret} and \id{yout} correspond to
  the farthest point reached in the integration.  On all other error returns,
  \id{tret} and \id{yout} are left unchanged from the previous \id{CVode}
  return.

}

%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

{\cvodes} provides an extensive set of functions that can be used to change
from their default values various optional input parameters that control the
behavior of the {\cvodes} solver. 
Table \ref{t:optional_input} lists all optional input functions in {\cvodes} which 
are then described in detail in the remainder of this section, begining with those
for the main {\cvodes} solver and continuing with those for the linear solver
modules. Note that the diagonal linear solver module has no optional inputs.
For the most casual use of {\cvodes}, the reader can skip to \S\ref{ss:user_fct_sim}.

We note that, on error return, all of the optional input functions send an
error message to the error handler function. \index{error messages}
We also note that all error return values are negative, so the test \id{flag < 0}
will catch all errors.

\begin{table}
\centering
\caption{Optional inputs for {\cvodes}, {\cvdense}, {\cvband}, and {\cvspils}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf CVODE main solver} \\
\hline
Error handler function & \id{CVodeSetErrHandlerFn} & internal fn. \\
Pointer to an error file & \id{CVodeSetErrFile} & \id{stderr}  \\
Data for right-hand side function & \id{CVodeSetFdata} & {\tt NULL} \\
Maximum order for BDF method & \id{CVodeSetMaxOrd} & 5 \\
Maximum order for Adams method & \id{CVodeSetMaxOrd} & 12  \\
Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$ & \id{CVodeSetMaxNumSteps} & 500 \\
Maximum no. of warnings for $t_n+h=t_n$ & \id{CVodeSetMaxHnilWarns} & 10 \\
Flag to activate stability limit detection & \id{CVodeSetStabLimDet} & {\tt FALSE} \\
Initial step size & \id{CVodeSetInitStep} & estimated \\
Minimum absolute step size & \id{CVodeSetMinStep} & 0.0 \\
Maximum absolute step size & \id{CVodeSetMaxStep} & $\infty$ \\
Value of $t_{stop}$ & \id{CVodeSetStopTime} & undefined \\
Maximum no. of error test failures & \id{CVodeSetMaxErrTestFails} & 7 \\
Maximum no. of nonlinear iterations & \id{CVodeSetMaxNonlinIters} & 3 \\
Maximum no. of convergence failures & \id{CVodeSetMaxConvFails} & 10 \\
Coefficient in the nonlinear convergence test & \id{CVodeSetNonlinConvCoef} & 0.1 \\
Nonlinear iteration type & \id{CVodeSetIterType} & none \\
Integration tolerances & \id{CVodeSetTolerances} & none \\
Ewt compuation function & \id{CVodeSetEwtFn} & internal fn. \\
\hline
\multicolumn{3}{|c|}{\bf CVDENSE linear solver} \\
\hline
Dense Jacobian function and data & \id{CVDenseSetJacFn} & internal DQ, \\
&&NULL\\
\hline
\multicolumn{3}{|c|}{\bf CVBAND linear solver} \\
\hline
Band Jacobian function and data & \id{CVBandSetJacFn} & internal DQ, \\
&&NULL\\
\hline
\multicolumn{3}{|c|}{\bf CVSPILS linear solvers} \\
\hline
Preconditioner functions and data & \id{CVSpilsSetPreconditioner} & all NULL \\
Jacobian-times-vector function and data & \id{CVSpilsSetJacTimesVecFn} & internal DQ, \\
&&NULL\\
Preconditioning type & \id{CVSpilsSetPrecType} & none \\
Ratio between linear and nonlinear tolerances & \id{CVSpilsSetDelt} & 0.05 \\
Type of Gram-Schmidt orthogonalization${}^{(a)}$ & \id{CVSpilsSetGSType} & classical GS \\
Maximum Krylov subspace size${}^{(b)}$ & \id{CVSpilsSetMaxl} & 5 \\
\hline
\multicolumn{3}{l}{}\\
\multicolumn{3}{l}{${}^{(a)}$ Only for {\cvspgmr}}\\
\multicolumn{3}{l}{${}^{(b)}$ Only for {\cvspbcg} and {\cvsptfqmr}}
\end{tabular}
\end{table}

%%==============================================================================
\subsubsection{Main solver optional input functions}\label{sss:optin_main}
%%==============================================================================
\index{optional input!solver|(}

The calls listed here can be executed in any order. \\
However, if \id{CVodeSetErrHandlerFn}
or \id{CVodeSetErrFile} are to be called, that call should be first, in order to take 
effect for any later error message.
%%
\index{error messages!user-defined handler}
\ucfunction{CVodeSetErrHandlerFn}
{
flag = CVodeSetErrHandlerFn(cvode\_mem, ehfun, eh\_data);
}
{
  The function \ID{CVodeSetErrHandlerFn} specifies the optional user-defined function
  to be used in handling error messages.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ehfun] (\id{CVErrHandlerFn}) 
    is the {\C} error handler function (see \S\ref{ss:ehFn}).
  \item[eh\_data] (\id{void *})
    pointer to user data passed to \id{ehfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The function \id{ehfun} and data pointer \id{eh\_data} have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default internal error handler function directs error messages to the
  file specified by the file pointer \id{errfp} (see \id{CVodeSetErrFile} below).

  Error messages indicating that the {\cvodes} solver memory is \id{NULL} will 
  always be directed to \id{stderr}.
}
%%
\index{error messages}
\ucfunction{CVodeSetErrFile}
{
flag = CVodeSetErrFile(cvode\_mem, errfp);
}
{
  The function \Id{CVodeSetErrFile} specifies a pointer to the file
  where all {\cvodes} messages should be directed in case the default
  {\cvodes} error handler function is used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}. 

  Passing a value of \id{NULL} disables all future error message output
  (except for the case in which the {\cvodes} memory pointer is \id{NULL}).

  {\warn}If \id{CVodeSetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error message.
}
%%
%%
\ucfunction{CVodeSetFdata}
{
  flag = CVodeSetFdata(cvode\_mem, f\_data);
}
{
  The function \Id{CVodeSetFdata} specifies the user-defined data block \Id{f\_data}
  to be passed to the user-supplied right-hand side function $f$, and attaches it to the main 
  {\cvodes} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[f\_data] (\id{void *})
    pointer to the user-defined data block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If \id{f\_data} is not specified, a \id{NULL} pointer is
  passed to the $f$ function.
}
%%
%%
\ucfunction{CVodeSetMaxOrd}
{
flag = CVodeSetMaxOrder(cvode\_mem, maxord);
}
{
  The function \Id{CVodeSetMaxOrder} specifies the maximum order of the 
  linear multistep method.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxord] (\id{int})
    value of the maximum method order.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The specified value \id{maxord} is negative or larger than 
    its previous value.
  \end{args}
}
{
  The default value is \id{ADAMS\_Q\_MAX = 12} for
  the Adams-Moulton method and \id{BDF\_Q\_MAX = 5}
  for the BDF method.
  Since \Id{maxord} affects the memory requirements
  for the internal {\cvodes} memory block, its value
  cannot be increased past its previous value.
}
%%
%%
\ucfunction{CVodeSetMaxNumSteps}
{
flag = CVodeSetMaxNumSteps(cvode\_mem, mxsteps);
}
{
  The function \Id{CVodeSetMaxNumSteps} specifies the maximum number
  of steps to be taken by the solver in its attempt to reach 
  the next output time.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[mxsteps] (\id{long int})
    maximum allowed number of steps.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    \id{mxsteps} is non-positive.
  \end{args}
}
{
   Passing \id{mxsteps}$=0$ results in {\cvodes} using the default value ($500$).
}
%%
%%
\ucfunction{CVodeSetMaxHnilWarns}
{
flag = CVodeSetMaxHnilWarns(cvode\_mem, mxhnil);
}
{
  The function \Id{CVodeSetMaxHnilWarns} specifies the maximum number of
  messages issued by the solver warning that $t+h=t$ on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[mxhnil] (\id{int})
    maximum number of warning messages
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $10$.
  A negative value for \id{mxhnil} indicates that no warning messages should
  be issued.
}
%%
%%
\ucfunction{CVodeSetStabLimDet}
{
flag = CVodeSetstabLimDet(cvode\_mem, stldet);
}
{
  The function \Id{CVodeSetStabLimDet} indicates if
  the BDF stability limit detection algorithm should be used. See \S\ref{s:bdf_stab}
  for further details.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[stldet] (\id{booleantype})
    flag controlling stability limit detection (\id{TRUE} = on; \id{FALSE} = off).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The linear multistep method is not set to \id{CV\_BDF}.
  \end{args}
}
{
  The default value is \id{FALSE}. If \id{stldet = TRUE} when BDF is used
  and the method order is greater than or equal to 3, then an internal function, \id{CVsldet},
  is called to detect a possible stability limit. If such a limit is detected, then the order is
  reduced.
}
%%
%%
\ucfunction{CVodeSetInitStep}
{
flag = CVodeSetInitStep(cvode\_mem, hin);
}
{
  The function \Id{CVodeSetInitStep} specifies the initial step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hin] (\id{realtype})
    value of the initial step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  By default, {\cvodes} estimates the initial step size to be the solution $h$ 
  of the equation $\| 0.5 h^2 {\ddot y} \|_{\mbox{\scriptsize WRMS}} = 1$,
  where ${\ddot y}$ is an estimated second derivative of the solution at \id{t0}.
}
%%
%%
\index{step size bounds|(}
\ucfunction{CVodeSetMinStep}
{
flag = CVodeSetMinStep(cvode\_mem, hmin);
}
{
  The function \Id{CVodeSetMinStep} specifies a lower bound on the magnitude
  of the step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hmin] (\id{realtype})
    minimum absolute value of the step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    Either \id{hmin} is nonpositive or it exceeds the maximum allowable step size.
  \end{args}
}
{
  The default value is $0.0$.
}
%%
%%
\ucfunction{CVodeSetMaxStep}
{
flag = CVodeSetMaxStep(cvode\_mem, hmax);
}
{
  The function \Id{CVodeSetMaxStep} specifies an upper bound on the magnitude
  of the step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hmax] (\id{realtype})
    maximum absolute value of the step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    Either \id{hmax} is nonpositive or it is smaller than the minimum allowable step size.
  \end{args}
}
{
  Pass \id{hmax}$=0$ to obtain the default value $\infty$.
}
\index{step size bounds|)}
%%
%%
\ucfunction{CVodeSetStopTime}
{
flag = CVodeSetStopTime(cvode\_mem, tstop);
}
{
  The function \Id{CVodeSetStopTime} specifies the value of the
  independent variable $t$ past which the solution is not to proceed.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tstop] (\id{realtype})
    value of the independent variable past which the solution should
    not proceed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $\infty$.
}
%%
%%
\ucfunction{CVodeSetMaxErrTestFails}
{
flag = CVodeSetMaxErrTestFails(cvode\_mem, maxnef);
}
{
  The function \Id{CVodeSetMaxErrTestFails} specifies the
  maximum number of error test failures permitted in attempting one step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxnef] (\id{int})
    maximum number of error test failures allowed on one step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $7$.
}
%%
%%
\ucfunction{CVodeSetMaxNonlinIters}
{
flag = CVodeSetMaxNonlinIters(cvode\_mem, maxcor);
}
{
  The function \Id{CVodeSetMaxNonlinIters} specifies the maximum
  number of nonlinear solver iterations permitted per step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxcor] (\id{int})
    maximum number of nonlinear solver iterations allowed per step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $3$.
}
%%
%%
\ucfunction{CVodeSetMaxConvFails}
{
flag = CVodeSetMaxConvFails(cvode\_mem, maxncf);
}
{
  The function \Id{CVodeSetMaxConvFails} specifies the
  maximum number of nonlinear solver convergence failures permitted during
  one step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxncf] (\id{int})
    maximum number of allowable nonlinear solver convergence failures
    per step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $10$.
}
%%
%%
\ucfunction{CVodeSetNonlinConvCoef}
{
flag = CVodeSetNonlinConvCoef(cvode\_mem, nlscoef);
}
{
  The function \Id{CVodeSetNonlinConvCoef} specifies the safety factor used
  in the nonlinear convergence test (see \S\ref{ss:ivp_sol}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlscoef] (\id{realtype})
    coefficient in nonlinear convergence test.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $0.1$.
}
%%
\ucfunction{CVodeSetIterType}
{
flag = CVodeSetIterType(cvode\_mem, iter);
}
{
  The function \Id{CVodeSetIterType} resets the nonlinear solver
  iteration type to \Id{iter}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[iter] (\id{int})
    specifies the type of nonlinear solver iteration and may be
    either \Id{CV\_NEWTON} or \Id{CV\_FUNCTIONAL}. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The \id{iter} value passed is neither \Id{CV\_NEWTON} nor \Id{CV\_FUNCTIONAL}.
  \end{args}
}
{
  The nonlinear solver iteration type is initially specified in the call
  to \id{CVodeCreate} (see \S\ref{sss:cvodemalloc}). This function call is
  needed only if \id{iter} is being changed from its value in the prior call 
  to \id{CVodeCreate}.
}
%%
%%
\ucfunction{CVodeSetTolerances}
{
flag = CVodeSetTolerances(cvode\_mem, itol, reltol, abstol);
}
{
  The function \Id{CVodeSetTolerances} resets the integration tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[itol] (\id{int}) 
    is either \Id{CV\_SS} or \Id{CV\_SV}, where \id{itol = CV\_SS} indicates scalar
    relative error tolerance and scalar absolute error tolerance, while
    \id{itol}$=$\id{CV\_SV} indicates scalar relative error tolerance and vector
    absolute error tolerance.  The latter choice is important when the absolute
    error tolerance needs to be different for each component of the ODE. 
  \item[reltol] (\id{realtype})
    \index{tolerances}
    the relative error tolerance.
  \item[abstol] (\id{void *})
    is a pointer to the absolute error tolerance.  If \id{itol}$=$\id{CV\_SS}, \id{abstol}
    must be a pointer to a \id{realtype} variable. If \id{itol}$=$\id{CV\_SV}, \id{abstol}
    must be an \id{N\_Vector} variable.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    The tolerances have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    An input argument has an illegal value.
  \end{args}
}
{
  The integration tolerances are initially specified in the call
  to \id{CVodeMalloc} (see \S\ref{sss:cvodemalloc}). This function call is
  needed only if the tolerances are being changed from their values beween
  successiv calls to \id{CVode}.

  {\warn}It is the user's responsibility to provide compatible \id{itol} and
  \id{abstol} arguments.

  It is illegal to call \id{CVodeSetTolerances} before a call to 
  \id{CVodeMalloc}.
}
%%
%%
\ucfunction{CVodeSetEwtFn}
{
flag = CVodeSetEwtFn(cvode\_mem, efun, e\_data);
}
{
  The function \Id{CVodeSetEwtFn} specifies the user-defined function
  to be used in computing the error weight vector $W$, which is normally
  defined by Eq.(\ref{e:errwt}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[efun] (\id{CVEwtFn}) 
    is the {\C} function which defines the \id{ewt} vector (see \S\ref{ss:ewtsetFn}).
  \item[e\_data] (\id{void *})
    pointer to user data passed to \id{efun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
     The function \id{efun} and data pointer \id{e\_data} have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This function can be called between successive calls to \id{CVode}.
  
  If not needed, pass \id{NULL} for \id{edata}.

  {\warn}It is illegal to call \id{CVodeSetEwtFn} before a call to \id{CVodeMalloc}.
}
%%
%%
\index{optional input!solver|)}

%%==============================================================================
\subsubsection{Dense linear solver}\label{sss:optin_dense}
%%==============================================================================
\index{optional input!dense linear solver|(}
\index{CVDENSE@{\cvdense} linear solver!optional input|(}
The \index{CVDENSE@{\cvdense} linear solver!Jacobian approximation used by}
{\cvdense} solver needs a function to compute a dense approximation to
the Jacobian matrix $J(t,y)$.  This function must be of type \id{CVDenseJacFn}. 
The user can supply his/her own dense Jacobian function, or use the default 
difference quotient function \Id{CVDenseDQJac} 
\index{Jacobian approximation function!dense!difference quotient}
that comes with the {\cvdense} solver.
To specify a user-supplied Jacobian function \id{djac} and associated user 
data \id{jac\_data}, {\cvdense} provides the function \id{CVDenseSetJacFn}.
The {\cvdense} solver passes the pointer \id{jac\_data} 
to its dense Jacobian function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program.  The pointer \id{jac\_data} may be
identical to \id{f\_data}, if the latter was specified through \id{CVodeSetFdata}.
%%
\index{Jacobian approximation function!dense!user-supplied}
\ucfunction{CVDenseSetJacFn}
{
  flag = CVDenseSetJacFn(cvode\_mem, djac, jac\_data);
}
{
  The function \Id{CVDenseSetJacFn} specifies the dense Jacobian
  approximation function to be used and the pointer to user data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[djac] (\id{CVDenseJacFn})
    user-defined dense Jacobian approximation function.
  \item[jac\_data] (\id{void *})
    pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDENSE\_LMEM\_NULL]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_LMEM\_NULL}]
    The {\cvdense} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\cvdense} uses the difference quotient function \id{CVDenseDQJac}.
  If \id{NULL} is passed to \id{djac}, this default function is used.

  The function type \id{CVDenseJacFn} is described in \S\ref{ss:djacFn}.
}
\index{CVDENSE@{\cvdense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}

%%==============================================================================
\subsubsection{Band linear solver}\label{sss:optin_band}
%%==============================================================================
\index{optional input!band linear solver|(}
\index{CVBAND@{\cvband} linear solver!optional input|(}
The \index{CVBAND@{\cvband} linear solver!Jacobian approximation used by}
{\cvband} solver needs a function to compute a banded approximation to
the Jacobian matrix $J(t,y)$.  This function must be of type \id{CVBandJacFn}. 
The user can supply his/her own banded Jacobian approximation function, 
or use the default difference quotient function \Id{CVBandDQJac} 
\index{Jacobian approximation function!band!difference quotient}
that comes with the {\cvband} solver.
To specify a user-supplied Jacobian function \id{bjac} and associated user 
data \id{jac\_data}, {\cvband} provides the function \id{CVBandSetJacFn}.
The {\cvband} solver passes the pointer \id{jac\_data}
to its banded Jacobian approximation function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program.  The pointer \id{jac\_data} may be
identical to \id{f\_data}, if the latter was specified through \id{CVodeSetFdata}.
%%
\index{Jacobian approximation function!band!user-supplied}
\ucfunction{CVBandSetJacFn}
{
  flag = CVBandSetJacFn(cvode\_mem, bjac, jac\_data);
}
{
  The function \Id{CVBandSetJacFn} specifies the banded Jacobian
  approximation function to be used and the pointer to user data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[bjac] (\id{CVBandJacFn})
    user-defined banded Jacobian approximation function.
  \item[jac\_data] (\id{void *})
    pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBAND\_LMEM\_NULL]
  \item[\Id{CVBAND\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_LMEM\_NULL}]
    The {\cvband} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\cvband} uses the difference quotient function \id{CVBandDQJac}.
  If \id{NULL} is passed to \id{bjac}, this default function is used.

  The function type \id{CVBandJacFn} is described in \S\ref{ss:bjacFn}.
}
\index{CVBAND@{\cvband} linear solver!optional input|)}
\index{optional input!band linear solver|)}

%%==============================================================================
\subsubsection{SPILS linear solver}\label{sss:optin_spils}
%%==============================================================================
\index{optional input!iterative linear solver|(}
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|(}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|(}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|(}
\index{preconditioning!user-supplied|(}
If any preconditioning is to be done within one of the {\cvspils} linear
solvers, then the user must supply a preconditioner solve function \id{psolve}
and specify its name in a call to \id{CVSpilsSetPreconditioner}.
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner solve function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner solve function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner solve function}
%%
The evaluation and preprocessing of any Jacobian-related data needed
by the user's preconditioner solve function is done in the optional
user-supplied function \id{psetup}. Both of these functions are
fully specified in \S\ref{ss:user_fct_sim}.
If used, the \id{psetup} function should also be specified in the call to
\id{CVSpilsSetPreconditioner}.
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner setup function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner setup function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner setup function}
%%
Optionally, a {\cvspils} solver passes the pointer \id{p\_data}
received through \id{CVSpilsSetPreconditioner} to the preconditioner
\id{psetup} and \id{psolve} functions.  This allows the user to create
an arbitrary structure with relevant problem data and access it during
the execution of the user-supplied preconditioner functions without using
global data in the program.  The pointer \id{p\_data} may be identical
to \id{f\_data}, if the latter was specified through \id{CVodeSetFdata}.

\index{CVSPGMR@{\cvspgmr} linear solver!Jacobian approximation used by}
\index{CVSPBCG@{\cvspbcg} linear solver!Jacobian approximation used by}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!Jacobian approximation used by}
Ther {\cvspils} solvers require a function to compute an approximation to the
product between the Jacobian matrix $J(t,y)$ and a vector $v$.
The user can supply his/her own Jacobian-times-vector approximation function, 
or use the difference quotient function \Id{CVSpilsDQJtimes} 
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\cvspils} solvers.  A user-defined Jacobian-vector
function must be of type \id{CVSpilsJacTimesVecFn} and 
can be specified through a call to \id{CVSpilsSetJacTimesVecFn} 
(see \S\ref{ss:jtimesFn} for specification details).
%%
As with the preconditioner user data structure \id{p\_data}, 
the user can also specify, in the call to \id{CVSpilsSetJacTimesVecFn}, a
pointer to a user-defined data structure, \id{jac\_data}, which
the {\cvspils} solver passes to the Jacobian-times-vector function \id{jtimes}
each time it is called.  
The pointer \id{jac\_data} may be identical to \id{p\_data} and/or \id{f\_data}.
%%
%%
\ucfunction{CVSpilsSetPreconditioner}
{
  flag = CVSpilsSetPreconditioner(cvode\_mem, psetup, psolve, p\_data);
}
{
  The function \ID{CVSpilsSetPreconditioner} specifies the preconditioner
  setup and solve functions and the pointer to user data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[psetup] (\id{CVSpilsPrecSetupFn})
    user-defined preconditioner setup function.
  \item[psolve] (\id{CVSpilsPrecSolveFn})
    user-defined preconditioner solve function.
  \item[p\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{CVSpilsPrecSolveFn} is described in \S\ref{ss:psolveFn}.
   The function type \id{CVSpilsPrecSetupFn} is described in \S\ref{ss:precondFn}.
}
%%
%%
\index{preconditioning!user-supplied|)}
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunction{CVSpilsSetJacTimesVecFn}
{
  flag = CVSpilsSetJacTimesVecFn(cvode\_mem, jtimes, jac\_data);
}
{
  The function \ID{CVSpilsSetJacTimesFn} specifies the Jacobian-vector 
  function to be used and the pointer to user data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[jtimes] (\id{CVSpilsJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \item[jac\_data] (\id{void *})
     pointer to the user-defined data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
  By default, the {\cvspils} linear solvers use an internal difference quotient 
  function \id{CVSpilsDQJtimes}.
  If \id{NULL} is passed to \id{jtimes}, this default function is used.

  The function type \id{CVSpilsJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.
}
%%
%%
\ucfunction{CVSpilsSetPrecType}
{
  flag = CVSpilsSetPrecType(cvode\_mem, pretype);
}
{
  The function \ID{CVSpilsSetPrecType} resets the type
  of preconditioning to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    specifies the type of preconditioning and must be one of:
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \end{args}
}
{
  The preconditioning type is initially set in the call
  to the linear solver's specification function (see \S\ref{sss:lin_solv_init}). 
  This function call is needed only if \id{pretype} is being changed from its original 
  value.
}
%%
%%
\ucfunction{CVSpilsSetGSType}
{
  flag = CVSpilsSetGSType(cvode\_mem, gstype);
}
{
  The function \ID{CVSpilsSetGSType} specifies the 
  Gram-Schmidt orthogonalization to be used with the {\cvspgmr} solver
  (one of the enumeration constants \ID{MODIFIED\_GS}
  or \ID{CLASSICAL\_GS}). These correspond to using modified Gram-Schmidt 
  and classical Gram-Schmidt, respectively. 
  \index{Gram-Schmidt procedure}
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[gstype] (\id{int})
    type of Gram-Schmidt orthogonalization.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The Gram-Schmidt orthogonalization type \id{gstype} is not valid.
  \end{args}
}
{
  The default value is \id{MODIFIED\_GS}.

  {\warn}This option is available only for the {\cvspgmr} linear solver.
}
%%
%%
\ucfunction{CVSpilsSetDelt}
{
  flag = CVSpilsSetDelt(cvode\_mem, delt);
}
{
  The function \ID{CVSpilsSetDelt} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the Newton iteration test constant.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[delt] (\id{realtype})

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The factor \id{delt} is negative.  
  \end{args}
}
{
  The default value is $0.05$.

  Passing a value \id{delt}$ = 0.0$ also indicates using the default value.
}
%%
\ucfunction{CVSpilsSetMaxl}
{
  flag = CVSpilsSetMaxl(cv\_mem, maxl);
}
{
  The function \Id{CVSpilsSetMaxl} resets maximum Krylov subspace
  dimension for the Bi-CGStab\index{Bi-CGStab method} or TFQMR\index{TFQMR method} 
  methods.
}
{
  \begin{args}[cv\_mem]
  \item[cv\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfuly set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cv\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
  The maximum subspace dimension is initially specified in the call
  to the linear solver specification function (see \S\ref{sss:lin_solv_init}). 
  This function call is needed only if \id{maxl} is being changed from its 
  previous value.

  {\warn}This option is available only for the {\cvspbcg} and {\cvsptfqmr} linear solvers.
}
%%
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|)}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|)}
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}


%%==============================================================================
\subsection{Interpolated output function}\label{ss:optional_dky}
%%==============================================================================
\index{optional output!interpolated solution}

An optional function \Id{CVodeGetDky} is available to obtain additional
output values.  This function should only be called after a successful
return from \id{CVode} as it provides interpolated values either of
$y$ or of its derivatives (up to the current order of the integration
method) interpolated to any value of $t$ in the last internal step
taken by {\cvodes}.

The call to the \id{CVodeGetDky} function has the following form:
%%
\ucfunction{CVodeGetDky}
{
  flag = CVodeGetDky(cvode\_mem, t, k, dky);
}
{
  The function \Id{CVodeGetDky} computes the \id{k}-th derivative of the function
  \id{y} at time \id{t}, i.e. $d^{(k)}y/dt^{(k)} (t)$, where $t_n - h_u \le$
  \id{t} $\le t_n$, $t_n$ denotes the current internal time reached, and $h_u$
  is the  last internal step size successfully used by the solver.  The 
  user may request \id{k} $= 0, 1, ..., q_u$, where $q_u$ is the current order. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[t] (\id{realtype})  the value of the independent variable at
    which the derivative is to be evaluated.
  \item[k] (\id{int}) the derivative order requested.
  \item[dky] (\id{N\_Vector})
    vector containing the derivative.
    This vector must be allocated by the user. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL] 
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetDky} succeeded.
  \item[\Id{CV\_BAD\_K}] 
    \id{k} is not in the range $0, 1, ..., q_u$.
  \item[\Id{CV\_BAD\_T}] 
    \id{t} is not in the interval $[t_n - h_u , t_n]$.
  \item[\Id{CV\_BAD\_DKY}] 
    The \id{dky} argument was \id{NULL}.
  \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} argument was \id{NULL}.
  \end{args}

}
{
  It is only legal to call the function \id{CVodeGetDky} after a 
  successful return from \id{CVode}. See \id{CVodeGetCurrentTime},
  \id{CVodeGetLastOrder}, and \id{CVodeGetLastStep} in the next section for
  access to $t_n$, $q_u$, and $h_u$, respectively.
}

%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\cvodes} provides an extensive set of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\cvodes},
which are then described in detail in the remainder of this section, begining with those
for the main {\cvodes} solver and continuing with those for the linear solver
modules. Where the name of an output from a linear solver module would otherwise conflict 
with the name of an optional output from the main solver, a suffix \id{LS} (for Linear Solver) 
has been added here (e.g. \id{lenrwLS}).

\begin{table}
\centering
\caption{Optional outputs from {\cvodes}, {\cvdense}, {\cvband}, {\cvdiag}, and {\cvspils}}
\label{t:optional_output}
\medskip
\begin{tabular}{|l|l|} 
\hline
{\bf Optional output} & {\bf Function name} \\ 
\hline
\multicolumn{2}{|c|}{\bf CVODES main solver} \\
\hline
Size of {\cvodes} real and integer workspaces & \id{CVodeGetWorkSpace} \\
Cumulative number of internal steps & \id{CVodeGetNumSteps} \\
No. of calls to r.h.s. function & \id{CVodeGetNumRhsEvals} \\
No. of calls to linear solver setup function & \id{CVodeGetNumLinSolvSetups} \\
No. of local error test failures that have occurred & \id{CVodeGetNumErrTestFails} \\
Order used during the last step & \id{CVodeGetLastOrder} \\
Order to be attempted on the next step & \id{CVodeGetCurrentOrder} \\
No. of order reductions due to stability limit detection & \id{CVodeGetNumStabLimOrderReds} \\
Actual initial step size used & \id{CVodeGetActualInitStep} \\
Step size used for the last step & \id{CVodeGetLastStep} \\
Step size to be attempted on the next step & \id{CVodeGetCurrentStep} \\
Current internal time reached by the solver & \id{CVodeGetCurrentTime} \\
Suggested factor for tolerance scaling  & \id{CVodeGetTolScaleFactor} \\
Error weight vector for state variables & \id{CVodeGetErrWeights} \\
Estimated local error vector & \id{CVodeGetEstLocalErrors} \\
No. of nonlinear solver iterations & \id{CVodeGetNumNonlinSolvIters} \\
No. of nonlinear convergence failures & \id{CVodeGetNumNonlinSolvConvFails} \\
All {\cvodes} integrator statistics & \id{CVodeGetIntegratorStats} \\
{\cvodes} nonlinear solver statistics & \id{CVodeGetNonlinSolvStats} \\
Array showing roots found & \id{CvodeGetRootInfo} \\
No. of calls to user root function & \id{CVodeGetNumGEvals} \\
Name of constant associated with a return flag & \id{CVodeGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVDENSE linear solver} \\
\hline
Size of {\cvdense} real and integer workspaces & \id{CVDenseGetWorkSpace} \\
No. of Jacobian evaluations & \id{CVDenseGetNumJacEvals} \\
No. of r.h.s. calls for finite diff. Jacobian evals. & \id{CVDenseGetNumRhsEvals} \\ 
Last return from a {\cvdense} function & \id{CVDenseGetLastFlag} \\ 
Name of constant associated with a return flag & \id{CVDenseGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVBAND linear solver} \\
\hline
Size of {\cvband} real and integer workspaces & \id{CVBandGetWorkSpace} \\
No. of Jacobian evaluations & \id{CVBandGetNumJacEvals} \\
No. of r.h.s. calls for finite diff. Jacobian evals. & \id{CVBandGetNumRhsEvals} \\ 
Last return from a {\cvband} function & \id{CVBandGetLastFlag} \\ 
Name of constant associated with a return flag & \id{CVBandGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVDIAG linear solver} \\
\hline
Size of {\cvdiag} real and integer workspaces & \id{CVDiagGetWorkSpace} \\
No. of r.h.s. calls for finite diff. Jacobian evals. & \id{CVDiagGetNumRhsEvals} \\ 
Last return from a {\cvdiag} function & \id{CVDiagGetLastFlag} \\ 
Name of constant associated with a return flag & \id{CVDiagGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVSPILS linear solvers} \\
\hline
Size of real and integer workspaces & \id{CVSpilsGetWorkSpace} \\
No. of linear iterations & \id{CVSpilsGetNumLinIters} \\
No. of linear convergence failures & \id{CVSpilsGetNumConvFails} \\
No. of preconditioner evaluations & \id{CVSpilsGetNumPrecEvals} \\
No. of preconditioner solves & \id{CVSpilsGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{CVSpilsGetNumJtimesEvals} \\
No. of r.h.s. calls for finite diff. Jacobian-vector evals. & \id{CVSpilsGetNumRhsEvals} \\ 
Last return from a linear solver function & \id{CVSpilsGetLastFlag} \\ 
Name of constant associated with a return flag & \id{CVSpilsGetReturnFlagName} \\
\hline
\end{tabular}
\end{table}

%%==============================================================================
\subsubsection{Main solver optional output functions}\label{sss:optout_main}
%%==============================================================================
\index{optional output!solver|(}
%%
{\cvodes} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements, solver performance statistics, as well as additional data from
the {\cvodes} memory block (a suggested tolerance scaling factor, the error weight
vector, and the vector of estimated local errors). Functions are also provided to
extract statistics related to the performance of the {\cvodes} nonlinear solver
used. As a convenience, additional information extraction functions provide the
optional outputs in groups.
%%
These optional output functions are described next.
%%
%%
\ucfunction{CVodeGetWorkSpace}
{
  flag = CVodeGetWorkSpace(cvode\_mem, \&lenrw, \&leniw);
}
{
  The function \Id{CVodeGetWorkSpace} returns the
  {\cvodes} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\cvodes} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\cvodes} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  \index{memory requirements!CVODES@{\cvodes} solver}
  In terms of the problem size $N$, the maximum method order \id{maxord}, and
  the number \id{nrtfn} of root functions (see \S\ref{s:using_rootfinding}),
  the actual size of the real workspace, in \id{realtype} words, is
  given by the following:
  \begin{itemize}
  \item base value: \id{lenrw} $= 96 + ($\id{maxord+5}$)*N_r + 3*$\id{nrtfn};
  \item if \id{itol = CV\_SV}: \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \end{itemize}
  where $N_r$ is the number of real words in one \id{N\_Vector} ($\approx N$).

  The size of the integer workspace (without distinction between \id{int} 
  and \id{long int} words) is given by:
  \begin{itemize}
  \item base value: \id{leniw} $= 40 + ($\id{maxord+5}$)*N_i ~ + ~ $\id{nrtfn};  
  \item if \id{itol = CV\_SV}: \id{leniw} $=$ \id{leniw} $+ N_i$;
  \end{itemize}
  where $N_i$ is the number of integer words in one \id{N\_Vector}
  (= 1 for {\nvecs} and 2*\id{npes} for {\nvecp} and \id{npes} processors).

  For the default value of \id{maxord}, with no rootfinding, and with
  \id{itol} $\neq$ \id{CV\_SV}, these lengths are given roughly by:
  \begin{itemize}
  \item For the Adams method: \id{lenrw} $= 96 + 17N$ and \id{leniw} $= 57$ 
  \item For the BDF method: \id{lenrw} $= 96 + 10N$ and \id{leniw} $= 50$ 
  \end{itemize}

  Note that additional memory is allocated if quadratures and/or forward sensitivity
  integration is enabled. See \S\ref{ss:quad_malloc} and \S\ref{ss:sensi_malloc}
  for more details.
}
%%
\ucfunction{CVodeGetNumSteps}
{
  flag = CVodeGetNumSteps(cvode\_mem, \&nsteps);
}
{
  The function \Id{CVodeGetNumSteps} returns the cumulative number of internal 
  steps taken by the solver (total so far).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nsteps] (\id{long int})
    number of steps taken by {\cvodes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumRhsEvals}
{
  flag = CVodeGetNumRhsEvals(cvode\_mem, \&nfevals);
}
{
  The function \Id{CVodeGetNumRhsEvals} returns the 
  number of calls to the user's right-hand side function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevals] (\id{long int})
    number of calls to the user's \id{f} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The \id{nfevals} value returned by \id{CVodeGetNumRhsEvals} does not
  account for calls made to \id{f} by a linear solver or preconditioner 
  module. 
}
%%
%%
\ucfunction{CVodeGetNumLinSolvSetups}
{
  flag = CVodeGetNumLinSolvSetups(cvode\_mem, \&nlinsetups);
}
{
  The function \Id{CVodeGetNumLinSolvSetups} returns the
  number of calls made to the linear solver's setup function.
}
{
  \begin{args}[nlinsetups]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlinsetups] (\id{long int})
    number of calls made to the linear solver setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumErrTestFails}
{
  flag = CVodeGetNumErrTestFails(cvode\_mem, \&netfails);
}
{
  The function \Id{CVodeGetNumErrTestFails} returns the
  number of local error test failures that have occurred.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[netfails] (\id{long int})
    number of error test failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetLastOrder}
{
  flag = CVodeGetLastOrder(cvode\_mem, \&qlast);
}
{
  The function \Id{CVodeGetLastOrder} returns the
  integration method order used during the last internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[qlast] (\id{int})
    method order used on the last internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetCurrentOrder}
{
  flag = CVodeGetCurrentOrder(cvode\_mem, \&qcur);
}
{
  The function \Id{CVodeGetCurrentOrder} returns the
  integration method order to be used on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[qcur] (\id{int})
    method order to be used on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetLastStep}
{
  flag = CVodeGetLastStep(cvode\_mem, \&hlast);
}
{
  The function \Id{CVodeGetLastStep} returns the
  integration step size taken on the last internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetCurrentStep}
{
  flag = CVodeGetCurrentStep(cvode\_mem, \&hcur);
}
{
  The function \Id{CVodeGetCurrentStep} returns the
  integration step size to be attempted on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetActualInitStep}
{
  flag = CVodeGetActualInitStep(cvode\_mem, \&hinused);
}
{
  The function \Id{CVodeGetActualInitStep} returns the
  value of the integration step size used on the first step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Even if the value of the initial integration step size was specified
  by the user through a call to \id{CVodeSetInitStep}, this value might have 
  been changed by {\cvodes} to ensure that the step size is within the 
  prescribed bounds ($h_{\min} \le h_0 \le h_{\max}$), or to satisfy the
  local error test condition.
}
%%
%%
\ucfunction{CVodeGetCurrentTime}
{
  flag = CVodeGetCurrentTime(cvode\_mem, \&tcur);
}
{
  The function \Id{CVodeGetCurrentTime} returns the
  current internal time reached by the solver.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumStabLimOrderReds}
{
  flag = CVodeGetNumStabLimOrderReds(cvode\_mem, \&nslred);
}
{
  The function \Id{CVodeGetNumStabLimOrderReds} returns the
  number of order reductions dictated by the BDF stability limit 
  detection algorithm (see \S\ref{s:bdf_stab}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nslred] (\id{long int})
    number of order reductions due to stability limit detection.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If the stability limit detection algorithm was not initialized
  through a call to \id{CVodeSetStabLimDet}, then \id{nslred}=0.
}
%%
%%
\ucfunction{CVodeGetTolScaleFactor}
{
  flag = CVodeGetTolScaleFactor(cvode\_mem, \&tolsfac);
}
{
  The function \Id{CVodeGetTolScaleFactor} returns a
  suggested factor by which the user's tolerances 
  should be scaled when too much accuracy has been 
  requested for some internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tolsfac] (\id{realtype})
    suggested scaling factor for user-supplied tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetErrWeights}
{
  flag = CVodeGetErrWeights(cvode\_mem, eweight);
}
{
  The function \Id{CVodeGetErrWeights} returns the solution error weights at
  the current time. These are the reciprocals of the $W_i$ given by (\ref{e:errwt}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eweight] (\id{N\_Vector})
    solution error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{eweight}.
}
%%
%%
\ucfunction{CVodeGetEstLocalErrors}
{
  flag = CVodeGetEstLocalErrors(cvode\_mem, ele);
}
{
  The function \Id{CVodeGetEstLocalErrors} returns the
  vector of estimated local errors.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ele] (\id{N\_Vector})
    estimated local errors.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{ele}.

  The \id{ele} vector, togther with the \id{eweight} vector from
  \id{CVodeGetErrWeights}, can be used to determine how the various
  components of the system contributed to the estimated local error
  test.  Specifically, that error test uses the RMS norm of a vector
  whose components are the products of the components of the two vectors.
  Thus, for example, if there were recent error test failures, the components
  causing the failures are those with largest values for the products,
  denoted loosely as \id{eweight[i]*ele[i]}.
}
%%
%%
\ucfunction{CVodeGetIntegratorStats}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVodeGetIntegratorStats(&cvode\_mem, \&nsteps, \&nfevals, \\
                                   &\&nlinsetups, \&netfails, \&qlast, \&qcur, \\
                                   &\&hinused, \&hlast, \&hcur, \&tcur);
  \end{tabular}
}
{
  The function \Id{CVodeGetIntegratorStats} returns the {\cvodes} integrator
  statistics as a group.
}
{
  \begin{args}[nlinsetups]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nsteps] (\id{long int})
    number of steps taken by {\cvodes}.
  \item[nfevals] (\id{long int})
    number of calls to the user's \id{f} function.
  \item[nlinsetups] (\id{long int})
    number of calls made to the linear solver setup function.
  \item[netfails] (\id{long int})
    number of error test failures.
  \item[qlast] (\id{int})
    method order used on the last internal step.
  \item[qcur] (\id{int})
    method order to be used on the next internal step.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    the optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    the \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumNonlinSolvIters}
{
  flag = CVodeGetNumNonlinSolvIters(cvode\_mem, \&nniters);
}
{
  The function \Id{CVodeGetNumNonlinSolvIters} returns the
  number of nonlinear (functional or Newton) iterations performed. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations performed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNumNonlinSolvConvFails}
{
  flag = CVodeGetNumNonlinSolvConvFails(cvode\_mem, \&nncfails);
}
{
  The function \Id{CVodeGetNumNonlinSolvConvFails} returns the
  number of nonlinear convergence failures that have occurred.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetNonlinSolvStats}
{
  flag = CVodeGetNonlinSolvStats(cvode\_mem, \&nniters, \&nncfails);
}
{
  The function \Id{CVodeGetNonlinSolvStats} returns the
  {\cvodes} nonlinear solver statistics as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations performed.
  \item[nncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetReturnFlagName}
{
  name = CVodeGetReturnFlagName(flag);
}
{
  The function \ID{CVodeGetReturnFlagName} returns the
  name of the {\cvode} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvode} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{optional output!solver|)}

%%==============================================================================
\subsubsection{Dense linear solver}\label{sss:optout_dense}
%%==============================================================================
\index{optional output!dense linear solver|(}
\index{CVDENSE@{\cvdense} linear solver!optional output|(}
The following optional outputs are available from the {\cvdense} module:
workspace requirements, number of calls to the Jacobian routine, number of 
calls to the right-hand side routine for finite-difference Jacobian approximation,
and last return value from a {\cvdense} function.
%%
%%
\index{CVDENSE@{\cvdense} linear solver!memory requirements}
\index{memory requirements!CVDENSE@{\cvdense} linear solver}
\ucfunction{CVDenseGetWorkSpace}
{
  flag = CVDenseGetWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \Id{CVDenseGetWorkSpace} returns the
  {\cvdense} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvdense} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvdense} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDENSE\_LMEM\_NULL]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_LMEM\_NULL}]
    The {\cvdense} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$, the actual size of the real workspace
  is $2N^2$ \id{realtype} words, and the actual size of the integer workspace
  is $N$ integer words.
}
%%
%%
\ucfunction{CVDenseGetNumJacEvals}
{
  flag = CVDenseGetNumJacEvals(cvode\_mem, \&njevals);
}
{
  The function \Id{CVDenseGetNumJacEvals} returns the
  number of calls made to the dense Jacobian approximation function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDENSE\_LMEM\_NULL]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_LMEM\_NULL}]
    The {\cvdense} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVDenseGetNumRhsEvals}
{
  flag = CVDenseGetNumRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \Id{CVDenseGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function due to the 
  finite difference dense Jacobian approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls made to the user-supplied right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDENSE\_LMEM\_NULL]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_LMEM\_NULL}]
    The {\cvdense} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if the default 
  \id{CVDenseDQJac} difference quotient function is used.
}
%%
%%
\ucfunction{CVDenseGetLastFlag}
{
  flag = CVDenseGetLastFlag(cvode\_mem, \&lsflag);
}
{
  The function \Id{CVDenseGetLastFlag} returns the
  last return value from a {\cvdense} routine. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lsflag] (\id{int})
    the value of the last return flag from a {\cvdense} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDENSE\_LMEM\_NULL]
  \item[\Id{CVDENSE\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVDENSE\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDENSE\_LMEM\_NULL}]
    The {\cvdense} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvdense} setup function failed (\id{CVode} returned \id{CV\_LSETUP\_FAIL}),
  then the value of \id{lsflag} corresponds to the column index (numbered from one)
  of a diagonal element with value zero that was encountered during the LU
  factorization of the dense Jacobian matrix.
}
%%
%%
\ucfunction{CVDenseGetReturnFlagName}
{
  name = CVDenseGetReturnFlagName(flag);
}
{
  The function \ID{CVDenseGetReturnFlagName} returns the
  name of the {\cvdense} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvdense} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVDENSE@{\cvdense} linear solver!optional output|)}
\index{optional output!dense linear solver|)}


%%==============================================================================
\subsubsection{Band linear solver}\label{sss:optout_band}
%%==============================================================================
\index{optional output!band linear solver|(}
\index{CVBAND@{\cvband} linear solver!optional output|(}
The following optional outputs are available from the {\cvband} module:
workspace requirements, number of calls to the Jacobian routine, number of 
calls to the right-hand side routine for finite-difference Jacobian approximation,
and last return value from a {\cvband} function.
%%
%%
\index{CVBAND@{\cvband} linear solver!memory requirements} 
\index{memory requirements!CVBAND@{\cvband} linear solver}
\ucfunction{CVBandGetWorkSpace}
{
  flag = CVBandGetWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \Id{CVBandGetWorkSpace} returns the
  {\cvband} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvband} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvband} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBAND\_LMEM\_NULL]
  \item[\Id{CVBAND\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_LMEM\_NULL}]
    The {\cvband} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and Jacobian half-bandwidths, 
  the actual size of the real workspace is
  $(2$ \id{mupper}$+ 3$ \id{mlower}$+ 2)\, N$ \id{realtype} words,
  and the actual size of the integer workspace is $N$ integer words.
}
%%
%%
\ucfunction{CVBandGetNumJacEvals}
{
  flag = CVBandGetNumJacEvals(cvode\_mem, \&njevals);
}
{
  The function \Id{CVBandGetNumJacEvals} returns the
  number of calls made to the banded Jacobian approximation function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBAND\_LMEM\_NULL]
  \item[\Id{CVBAND\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_LMEM\_NULL}]
    The {\cvband} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVBandGetNumRhsEvals}
{
  flag = CVBandGetNumRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \Id{CVBandGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function due to the 
  finite difference banded Jacobian approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls made to the user-supplied right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBAND\_LMEM\_NULL]
  \item[\Id{CVBAND\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_LMEM\_NULL}]
    The {\cvband} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if the default 
  \id{CVBandDQJac} difference quotient function is used.
}
%%
%%
\ucfunction{CVBandGetLastFlag}
{
  flag = CVBandGetLastFlag(cvode\_mem, \&lsflag);
}
{
  The function \Id{CVBandGetLastFlag} returns the
  value of the last return flag from a {\cvband} routine. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lsflag] (\id{int})
    the value of the last return flag from a {\cvband} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBAND\_LMEM\_NULL]
  \item[\Id{CVBAND\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVBAND\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVBAND\_LMEM\_NULL}]
    The {\cvband} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvband} setup function failed (\id{CVode} returned \id{CV\_LSETUP\_FAIL}),
  the value of \id{lsflag} corresponds to the column index (numbered from one) of
  a diagonal element with value zero that was encountered during the LU
  factorization of the banded Jacobian matrix.
}
%%
%%
\ucfunction{CVBandGetReturnFlagName}
{
  name = CVBandGetReturnFlagName(flag);
}
{
  The function \ID{CVBandGetReturnFlagName} returns the
  name of the {\cvband} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvband} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVBAND@{\cvband} linear solver!optional output|)}
\index{optional output!band linear solver|)}


%%==============================================================================
\subsubsection{Diagonal linear solver}\label{sss:optout_diag}
%%==============================================================================
\index{optional output!diagonal linear solver|(}
\index{CVDIAG@{\cvdiag} linear solver!optional output|(}
The following optional outputs are available from the {\cvdiag} module:
workspace requirements, number of calls to the right-hand side routine for 
finite-difference Jacobian approximation, and last return value from a 
{\cvdiag} function.
%%
%%
\index{CVDIAG@{\cvdiag} linear solver!memory requirements} 
\index{memory requirements!CVDIAG@{\cvdiag} linear solver}
\ucfunction{CVDiagGetWorkSpace}
{
  flag = CVDiagGetWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \Id{CVDiagGetWorkSpace} returns the
  {\cvdiag} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvdiag} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvdiag} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}] 
    The optional output valus have been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$, the actual size of the real workspace
  is roughly $3 N$ \id{realtype} words.
}
%%
%%
\ucfunction{CVDiagGetNumRhsEvals}
{
  flag = CVDiagGetNumRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \Id{CVDiagGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function due to the 
  finite difference Jacobian approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls made to the user-supplied right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  The number of diagonal approximate Jacobians formed is
  equal to the number of calls made to the linear solver setup function
  (see \id{CVodeGetNumLinSolvSetups}).
}
%%
%%
\ucfunction{CVDiagGetLastFlag}
{
  flag = CVDiagGetLastFlag(cvode\_mem, \&lsflag);
}
{
  The function \Id{CVDiagGetLastFlag} returns the
  last return value from a {\cvdiag} routine. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lsflag] (\id{int})
    the value of the last return flag from a {\cvdiag} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvdiag} setup function failed (\id{CVode} returned \id{CV\_LSETUP\_FAIL}),
  the value of \id{lsflag} is equal to \id{CVDIAG\_INV\_FAIL}, indicating that a
  diagonal element with value zero was encountered.
  The same value is also returned if the {\cvdiag} solve function failed
  (\id{CVode} returned \id{CV\_LSOLVE\_FAIL}).
}
%%
%%
\ucfunction{CVDiagGetReturnFlagName}
{
  name = CVDiagGetReturnFlagName(flag);
}
{
  The function \ID{CVDiagGetReturnFlagName} returns the
  name of the {\cvdiag} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvdiag} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVDIAG@{\cvdiag} linear solver!optional output|)}
\index{optional output!diagonal linear solver|)}


%%==============================================================================
\subsubsection{SPILS linear solvers}\label{sss:optout_spils}
%%==============================================================================
\index{optional output!iterative linear solver|(}
\index{CVSPGMR@{\cvspgmr} linear solver!optional output|(} 
\index{CVSPBCG@{\cvspbcg} linear solver!optional output|(} 
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional output|(} 
The following optional outputs are available from the {\cvspils}
modules: workspace requirements, number of linear iterations, number of
linear convergence failures, number of calls to the preconditioner
setup and solve routines, number of calls to the Jacobian-vector
product routine, number of calls to the right-hand side routine for
finite-difference Jacobian-vector product approximation, and last
return value from a linear solver function.
%%
%%
\index{CVSPGMR@{\cvspgmr} linear solver!memory requirements} 
\index{CVSPBCG@{\cvspbcg} linear solver!memory requirements} 
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!memory requirements} 
\index{memory requirements!CVSPGMR@{\cvspgmr} linear solver}
\ucfunction{CVSpilsGetWorkSpace}
{
  flag = CVSpilsGetWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{CVSpilsGetWorkSpace} returns the global sizes of the
  {\cvspgmr} real and integer workspaces.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvspils} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvspils} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and maximum subspace size \id{maxl}, 
  the actual size of the real workspace is roughly:\\
  (\id{maxl}$+ 5)*N +$ \id{maxl} $*($ \id{maxl}$ + 4) + 1$ \id{realtype}
  words for {\cvspgmr},\\
  $9*N$ \id{realtype} words for {\cvspbcg},\\
  and $11*N$ \id{realtype} words for {\idasptfqmr}.

  In a parallel setting, the above values are global --- summed over all processors.
}
%%
%%
\ucfunction{CVSpilsGetNumLinIters}
{
  flag = CVSpilsGetNumLinIters(cvode\_mem, \&nliters);
}
{
  The function \ID{CVSpilsGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVSpilsGetNumConvFails}
{
  flag = CVSpilsGetNumConvFails(cvode\_mem, \&nlcfails);
}
{
  The function \ID{CVSpilsGetNumConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVSpilsGetNumPrecEvals}
{
  flag = CVSpilsGetNumPrecEvals(cvode\_mem, \&npevals);
}
{
  The function \ID{CVSpilsGetNumPrecEvals} returns the
  number of preconditioner evaluations, i.e., the number of 
  calls made to \id{psetup} with \id{jok = FALSE}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVSpilsGetNumPrecSolves}
{
  flag = CVSpilsGetNumPrecSolves(cvode\_mem, \&npsolves);
}
{
  The function \ID{CVSpilsGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner 
  solve function, \id{psolve}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVSpilsGetNumJtimesEvals}
{
  flag = CVSpilsGetNumJtimesEvals(cvode\_mem, \&njvevals);
}
{
  The function \ID{CVSpilsGetNumJtimesEvals} returns the
  cumulative number made to the Jacobian-vector function,
  \id{jtimes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVSpilsGetNumRhsEvals}
{
  flag = CVSpilsGetNumRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \ID{CVSpilsGetNumRhsEvals} returns the
  number of calls to the user right-hand side function for
  finite difference Jacobian-vector product approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if the default 
  \id{CVSpilsDQJtimes} difference quotient function is used.
}
%%
%%
\ucfunction{CVSpilsGetLastFlag}
{
  flag = CVSpilsGetLastFlag(cvode\_mem, \&lsflag);
}
{
  The function \ID{CVSpilsGetLastFlag} returns the
  last return value from a {\cvspils} routine. 
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[flag] (\id{int})
    the value of the last return flag from a {\cvspils} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVSPILS\_LMEM\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvspils} setup function failed (\id{CVode} returned
  \id{CV\_LSETUP\_FAIL}), \id{lsflag} will be \id{SPGMR\_PSET\_FAIL\_UNREC},
  \id{SPBCG\_PSET\_FAIL\_UNREC}, or \id{SPTFQMR\_PSET\_FAIL\_UNREC}.

  If the {\cvspgmr} solve function failed (\id{CVode} returned
  \id{CV\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpgmrSolve} and will be one of:
  \id{SPGMR\_MEM\_NULL}, indicating that the {\spgmr} memory is \id{NULL};
  \id{SPGMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  Jacobian-times-vector function;
  \id{SPGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably;
  \id{SPGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure; 
  or \id{SPGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase.

  If the {\cvspbcg} solve function failed (\id{CVode} returned
  \id{CV\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpbcgSolve} and will be one of:
  \id{SPBCG\_MEM\_NULL}, indicating that the {\spbcg} memory is \id{NULL};
  \id{SPBCG\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  Jacobian-times-vector function; or
  \id{SPBCG\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably.

  If the {\cvsptfqmr} solve function failed (\id{CVode} returned
  \id{CV\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SptfqmrSolve} and will be one of:
  \id{SPTFQMR\_MEM\_NULL}, indicating that the {\sptfqmr} memory is \id{NULL};
  \id{SPTFQMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  Jacobian-times-vector function; or
  \id{SPTFQMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably.
}
%%
%%
\ucfunction{CVSpilsGetReturnFlagName}
{
  name = CVSpilsGetReturnFlagName(flag);
}
{
  The function \ID{CVSpilsGetReturnFlagName} returns the
  name of the {\cvspils} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvspils} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVSPBCG@{\cvspbcg} linear solver!optional output|)} 
\index{CVSPGMR@{\cvspgmr} linear solver!optional output|)} 
\index{optional output!iterative linear solver|)}


%%==============================================================================
\subsection{CVODES reinitialization function}\label{sss:cvreinit}
%%==============================================================================
\index{reinitialization}

The function \Id{CVodeReInit} reinitializes the main {\cvodes} solver for
the solution of a problem, where a prior call to \Id{CVodeMalloc} has
been made. The new problem must have the same size as the previous one.
\id{CVodeReInit} performs the same input checking and initializations 
that \id{CVodeMalloc} does, but does no memory allocation as it assumes that the 
existing internal memory is sufficient for the new problem.             
                                                                 
The use of \id{CVodeReInit} requires that the maximum method order, denoted by 
\Id{maxord}, be no larger for the new problem than for the previous problem.
This condition is  
automatically fulfilled if the multistep method parameter \Id{lmm}  
is unchanged (or changed from \Id{CV\_ADAMS} to \Id{CV\_BDF}) and the default    
value for \id{maxord} is specified.

If there are changes to the linear solver specifications, make the
appropriate \id{CV*Set*} calls, as described in \S\ref{sss:lin_solv_init}

%%
%%
\ucfunction{CVodeReInit}
{
  flag = CVodeReInit(cvode\_mem, f, t0, y0, itol, reltol, abstol);
}
{
  The function \id{CVodeReInit} provides required problem specifications 
  and reinitializes {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[f] (\Id{CVRhsFn})
    is the {\C} function which computes $f$ in the ODE. This function has the form 
    \id{f(N, t, y, ydot, f\_data)} (for full details see \S\ref{ss:user_fct_sim}).
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$. 
  \item[itol] (\id{int}) 
    is one of \Id{CV\_SS}, \Id{CV\_SV}, or \Id{CV\_WF}, where \id{itol = CV\_SS} indicates scalar
    relative error tolerance and scalar absolute error tolerance, while
    \id{itol = CV\_SV} indicates scalar relative error tolerance and vector
    absolute error tolerance.  The latter choice is important when the absolute
    error tolerance needs to be different for each component of the ODE. 
    If \id{itol}$=$\id{CV\_WF}, the arguments \id{reltol} and \id{abstol} are ignored
    and the user is expected to provide a function to evaluate the error weight vector
    $W$ from (\ref{e:errwt}). See \id{CVodeSetEwtFn} in \S\ref{sss:optin_main}.
  \item[reltol] (\id{realtype})
    is the relative error tolerance.
  \item[abstol] (\id{void *})
    is a pointer to the absolute error tolerance.  If \id{itol}$=$\id{CV\_SS}, \id{abstol}
    must be a pointer to a \id{realtype} variable. If \id{itol}$=$\id{CV\_SV}, \id{abstol}
    must be an \id{N\_Vector} variable.
  \end{args}
}
{
  The return flag \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_NO\_MALLOC]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInit} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a 
    previous call to \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}] 
    Memory space for the {\cvodes} memory block was not allocated through a 
    previous call to \id{CVodeMalloc}.
  \item[\Id{CV\_ILL\_INPUT}] 
    An input argument to \id{CVodeReInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{CVodeReInit} also sends an error message to the
  error handler function.

  {\warn}It is the user's responsibility to provide compatible \id{itol} and
  \id{abstol} arguments.
}

%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sim}
%%==============================================================================

The user-supplied functions consist of one function defining the ODE, 
(optionally) a function that handles error and warning messages, 
(optionally) a function that provides the error weight vector, 
(optionally) a function that provides Jacobian-related information for the linear 
solver (if Newton iteration is chosen), and (optionally) one or two functions 
that define the preconditioner for use in any of the Krylov iterative algorithms.

%%==============================================================================
\subsection{ODE right-hand side} \label{ss:rhsFn}
%%==============================================================================
\index{right-hand side function}
The user must provide a function of type \Id{CVRhsFn} defined as follows:
\usfunction{CVRhsFn}
{
  typedef int (*CVRhsFn)(&realtype t, N\_Vector y, N\_Vector ydot, \\
                         &void *f\_data);
}
{
  This function computes the ODE right-hand side for a given value
  of the independent variable $t$ and state vector $y$.
}
{
  \begin{args}[f\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[ydot]
    is the output vector $f(t,y)$.
  \item[f\_data]
    is the \Id{f\_data}      
    pointer passed to \id{CVodeSetFdata}.   
  \end{args}
}
{
  A \id{CVRhsFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \Id{CV\_RHSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{ydot} is handled within {\cvodes}.

  {\warn}For efficiency considerations, the right-hand side function is not
  evaluated at the converged solution of the nonlinear solver. Therefore, a
  recoverable error in \id{CVRhsFn} at that point cannot be corrected (as it will 
  occur when the right-hand side function is called the first time during the 
  following integration step and a successful step cannot be undone). 
  However, if the use program also includes quadrature integration, the state variables
  can be checked for legality in the call to \id{CVQuadRhsFn} which is called at the 
  converged solution of the nonlinear system and therefore {\cvodes} can be flagged to 
  attempt to recover from such a situation. Also, if sensitivity analysis is performed
  with one of the staggered methods, the ODE right-hand side function is called at
  the converged solution of the nonlinear system and a recoverable error at that point
  will be captured and {\cvodes} will try to correct it.

  There are two other situations in which recovery is not possible even if the right-hand
  side function returns a recoverable error flag. This include the situation when this
  occurrs at the very first call to the \id{CVRhsFn} (in which case {\cvodes} returns
  \Id{CV\_FIRST\_RHSFUNC\_ERR}) or if a recoverable error is reported when \id{CVRhsFn}
  is called after an error test failure, while the linear multistep method order is
  equal to 1 (in which case {\cvodes} returns \Id{CV\_UNREC\_RHSFUNC\_ERR}).
}

%%==============================================================================
\subsection{Error message handler function}
\label{ss:ehFn}
%%==============================================================================
\index{error messages!user-defined handler}
As an alternative to the default behavior of directing error and warning messages 
to the file pointed to by \id{errfp} (see \id{CVSetErrFile}), the user may
provide a function of type \ID{CVErrHandlerFn} to process any such messages.
The function type \id{CVErrHandlerFn} is defined as follows:
\usfunction{CVErrHandlerFn}
{
  typedef void (*CVErrHandlerFn)(&int error\_code,  \\
                                 &const char *module, const char *function, \\ 
                                 &char *msg, void *eh\_data); 
}
{
  This function processes error and warning messages from {\cvodes} and 
  its sub-modules.
}
{
  \begin{args}[error\_code]
  \item[error\_code]
    is the error code.
  \item[module]
    is the name of the {\cvodes} module reporting the error.
  \item[function]
    is the name of the function in which the error occurred.
  \item[msg]
    is the error message.
  \item[eh\_data]
    is a pointer to user data, the same as the \Id{eh\_data}      
    parameter passed to \id{CVodeSetErrHandlerFn}.   
  \end{args}
}
{
  A \id{CVErrHandlerFn} function has no return value.
}
{
  \id{error\_code} is negative for errors and positive (\Id{CV\_WARNING}) for warnings.
  If a function returning a pointer to memory (e.g. \id{CVBBDPrecAlloc}) encounters an
  error, it sets \id{error\_code} to 0 before returning \id{NULL}.
}

%%==============================================================================
\subsection{Error weight function}
\label{ss:ewtsetFn}
%%==============================================================================
\index{tolerances}
As an alternative to providing the relative and absolute tolerances, the user may
provide a function of type \Id{CVEwtFn} to compute a vector \id{ewt} containing the
weights in the WRMS norm 
$\|\ v \|_{\mbox{\scriptsize WRMS}} = \sqrt{(1/N)\sum_1^N (W_i \cdot v_i)^2}$.
The function type \id{CVEwtFn} is defined as follows:
\usfunction{CVEwtFn}
{
  typedef int (*CVEwtFn)(N\_Vector y, N\_Vector ewt, void *e\_data);
}
{
  This function computes the WRMS error weights for the vector $y$.
}
{
  \begin{args}[e\_data]
  \item[y]
    is the value of the vector for which the WRMS norm must be computed.
  \item[ewt]
    is the output vector containing the error weights.
  \item[e\_data]
    is the \Id{e\_data}      
    pointer passed to \id{CVodeSetEwtFn}.   
  \end{args}
}
{
  A \id{CVEwtFn} function type must return $0$ if it successfuly set
  the error weights and $-1$ otherwise. In case of failure, a message is printed
  and the integration stops.
}
{
  Allocation of memory for \id{ewt} is handled within {\cvodes}.

  {\warn}The error weight vector must have all components positive. It is the
  user's responsiblity to perform this test and return $-1$ if it is not 
  satisfied.
}

%%==============================================================================
\subsection{Jacobian information (direct method with dense Jacobian)}
\label{ss:djacFn}
%%==============================================================================
\index{Jacobian approximation function!dense!user-supplied|(}

If the direct linear solver with dense treatment of the Jacobian is used 
(i.e., \Id{CVDense} is called in Step \ref{i:lin_solver} of \S\ref{ss:skeleton_sim}), 
the user may provide a function of type \Id{CVDenseJacFn} defined by:
\usfunction{CVDenseJacFn}
{
  typedef (*CVDenseJacFn)(&long int N, DenseMat J, realtype t, \\
                          &N\_Vector y, N\_Vector fy, void *jac\_data, \\
                          &N\_Vector tmp1, N\_Vector tmp2, N\_Vector tmp3);
}
{
  This function computes the dense Jacobian $J = \partial f / \partial y$ 
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[N]
    is the problem size.
  \item[J]
    is the output Jacobian matrix.  
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, 
    namely the predicted value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[jac\_data]
    is the \id{jac\_data}      
    pointer passed to \id{CVDenseSetJacFn}.   
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{CVDenseJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDenseJacFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvdense} sets
  \id{last\_flag} on \Id{CVDENSE\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVode}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} on 
  \Id{CVDENSE\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{N} by \id{N}
  dense matrix \id{J} with an approximation to the Jacobian matrix $J$
  at the point (\id{t}, \id{y}).  Only nonzero elements need to be loaded
  into \id{J} because \id{J} is set to the zero matrix before the call
  to the Jacobian function. The type of \id{J} is \Id{DenseMat}. 
  
  The accessor macros \Id{DENSE\_ELEM} and \Id{DENSE\_COL} allow the user to
  read and write dense matrix elements without making explicit
  references to the underlying representation of the \id{DenseMat}
  type. \id{DENSE\_ELEM(J, i, j)} references the (\id{i}, \id{j})-th
  element of the dense matrix \id{J} (\id{i}, \id{j }$= 0\ldots N-1$). This macro
  is meant for small problems for which efficiency of access is not a major
  concern.  Thus, in terms of the indices $m$ and $n$ ranging from $1$ to
  $N$, the Jacobian element $J_{m,n}$ can be set using the statement
  \id{DENSE\_ELEM(J, m-1, n-1) =} $J_{m,n}$.  Alternatively,
  \id{DENSE\_COL(J, j)} returns a pointer to the first element of
  the \id{j}-th column of \id{J} (\id{j }$= 0\ldots N-1$), and the 
  elements of the \id{j}-th column
  can then be accessed using ordinary array indexing.  Consequently, $J_{m,n}$ can be 
  loaded using the statements \id{col\_n = DENSE\_COL(J, n-1);}
  \id{col\_n[m-1] =} $J_{m,n}$.  For large problems, it is more 
  efficient to use \id{DENSE\_COL} than to use \id{DENSE\_ELEM}. 
  Note that both of these macros number rows and columns
  starting from $0$.  

  The \id{DenseMat} type and accessor macros \id{DENSE\_ELEM} and 
  \id{DENSE\_COL} are documented in \S\ref{ss:dense}.

  If the user's \id{CVDenseJacFn} function uses difference quotient
  approximations, then it may need to access quantities not in the argument
  list. These include the current step size, the error weights, etc.
  To obtain these, use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed
  as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!dense!user-supplied|)}

%%==============================================================================
\subsection{Jacobian information (direct method with banded Jacobian)}
\label{ss:bjacFn}
%%==============================================================================
\index{Jacobian approximation function!band!user-supplied|(}
\index{half-bandwidths|(}

If the direct linear solver with banded treatment of the Jacobian is used 
(i.e. \Id{CVBand} is called in Step \ref{i:lin_solver} of \S\ref{ss:skeleton_sim}), 
the user may provide a function of type \Id{CVBandJacFn} defined as follows:
\usfunction{CVBandJacFn}
{
 typedef int (*CVBandJacFn)(&long int N, long int mupper, \\
                            &long int mlower, BandMat J, realtype t, \\ 
                            &N\_Vector y, N\_Vector fy, void *jac\_data, \\
                            &N\_Vector tmp1, N\_Vector tmp2, N\_Vector tmp3);
}
{
  This function computes the banded Jacobian $J = \partial f / \partial y$ 
  (or a banded approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[N]
    is the problem size.
  \item[mlower]
  \item[mupper]
    are the lower and upper half-bandwidths of the Jacobian.
  \item[J]
    is the output Jacobian matrix.  
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, 
    namely the predicted value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[jac\_data]
    is the \id{jac\_data}      
    pointer passed to \id{CVBandSetJacFn}.   
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{CVBandJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVBandJacFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvband} sets
  \id{last\_flag} on \Id{CVBAND\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVode}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvband} sets \id{last\_flag} on 
  \Id{CVBAND\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{J}
  of type \Id{BandMat} with the elements of the Jacobian $J(t,y)$ at the
  point (\id{t},\id{y}).  Only nonzero elements need to be loaded into
  \id{J} because \id{J} is initialized to the zero matrix before the call to the
  Jacobian function.  

  The accessor macros \Id{BAND\_ELEM}, \Id{BAND\_COL}, and \Id{BAND\_COL\_ELEM} 
  allow the user to read and write band matrix elements without making specific 
  references to the underlying representation of the \id{BandMat} type.
  \id{BAND\_ELEM(J, i, j)} references the (\id{i}, \id{j})-th element of the 
  band matrix \id{J}, counting from $0$.
  This macro is meant for use in small problems for which efficiency of access is not
  a major concern.  Thus, in terms of the indices $m$ and $n$ ranging from $1$ to
  $N$ with $(m,n)$ within the band defined by \id{mupper} and
  \id{mlower}, the Jacobian element $J_{m,n}$ can be loaded using the 
  statement \id{BAND\_ELEM(J, m-1, n-1) =} $J_{m,n}$. The elements within
  the band are those with \id{-mupper} $\le$ \id{m-n} $\le$ \id{mlower}.
  Alternatively, \id{BAND\_COL(J, j)} returns a pointer to the diagonal element
  of the \id{j}-th column of \id{J}, and if we assign this address to 
  \id{realtype *col\_j}, then the \id{i}-th element of the \id{j}-th column is
  given by \id{BAND\_COL\_ELEM(col\_j, i, j)}, counting from $0$.
  Thus, for $(m,n)$ within the band, $J_{m,n}$ can be loaded by setting 
  \id{col\_n = BAND\_COL(J, n-1);} \id{BAND\_COL\_ELEM(col\_n, m-1, n-1) =}
  $J_{m,n}$.  The elements of the \id{j}-th column can also be accessed
  via ordinary array indexing, but this approach requires knowledge of
  the underlying storage for a band matrix of type \id{BandMat}.  
  The array \id{col\_n} can be indexed from $-$\id{mupper} to \id{mlower}.
  For large problems, it is more efficient to use
  \id{BAND\_COL} and \id{BAND\_COL\_ELEM} than to use the
  \id{BAND\_ELEM} macro.  As in the dense case, these macros all number rows
  and columns starting from $0$.  

  The \id{BandMat} type and the accessor macros \id{BAND\_ELEM}, \id{BAND\_COL} and
  \id{BAND\_COL\_ELEM} are documented in \S\ref{ss:band}.

  If the user's \id{CVBandJacFn} function uses difference quotient approximations, then
  it may need to access quantities not in the argument list. These include the current
  step size, the error weights, etc. To obtain these, use the \id{CVodeGet*}
  functions described in \S\ref{sss:optout_main}. The unit roundoff can be
  accessed as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{half-bandwidths|)}
\index{Jacobian approximation function!band!user-supplied|)}

%%==============================================================================
\subsection{Jacobian information (matrix-vector product)}\label{ss:jtimesFn}
%%==============================================================================
\index{Jacobian approximation function!Jacobian-vector product!user-supplied|(}

If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr}
is selected (\id{CVSp*} is called in step \ref{i:lin_solver} of
\S\ref{ss:skeleton_sim}), the user may provide a function of type
\Id{CVSpilsJacTimesVecFn} in the following form:
\usfunction{CVSpilsJacTimesVecFn}
{
  typedef int (*CVSpilsJacTimesVecFn)&(N\_Vector v, N\_Vector Jv, \\
                                     &realtype t, N\_Vector y, N\_Vector fy,\\
                                     &void *jac\_data, N\_Vector tmp);
}
{
  This function computes the product $J v = (\partial f / \partial y) v$ 
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[v]
    is the vector by which the Jacobian must be multiplied.
  \item[Jv]
      is the output vector computed.
  \item[t]
    is the current value of the independent variable.       
  \item[y] 
    is the current value of the dependent variable vector. 
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[jac\_data]
    is the \id{jac\_data}      
    pointer passed to \id{CVSp*SetJacTimesVecFn}.   
  \item[tmp]
    is a pointer to memory allocated for a variable of type \id{N\_Vector}
    which can be used for work space.
  \end{args}
}
{  
  The value to be returned by the Jacobian-vector product function should be
  $0$ if successful. Any other return value will result in an unrecoverable
  error of the {\spgmr} generic solver, in which case the integration is halted.
}
{
  If the user's \id{CVSpilsJacTimesVecFn} function uses difference quotient
  approximations, it may need to access quantities not in the argument
  list. These include the current step size, the error weights, etc.
  To obtain these, use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed
  as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied|)}

%%==============================================================================
\subsection{Preconditioning (linear system solution)} \label{ss:psolveFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner solve function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner solve function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner solve function}

If preconditioning is used, then the user must provide a {\C} function to
solve the linear system $Pz = r$, where $P$ may be either a left or
right preconditioner matrix.
This function must be of type \Id{CVSpilsPrecSolveFn}, defined as follows:
%%
%%
\usfunction{CVSpilsPrecSolveFn}
{
  typedef int (*CVSpilsPrecSolveFn)(&realtype t, N\_Vector y, N\_Vector fy, \\
                                    &N\_Vector r, N\_Vector z, \\ 
                                    &realtype gamma, realtype delta, \\
                                    &int lr, void *p\_data, N\_Vector tmp);
}
{
  This function solves the preconditioned system $Pz = r$.
}
{  
  \begin{args}[p\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y] 
    is the current value of the dependent variable vector.  
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[r]
    is the right-hand side vector of the linear system.
  \item[z]
    is the computed output vector.
  \item[gamma]
    is the scalar $\gamma$ appearing in the Newton matrix given by $M=I-\gamma J$.
  \item[delta]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.  In that case, the residual 
    vector $Res = r - P z$ of the system should be made less than 
    \id{delta} in the weighted $l_2$ norm,     
    i.e., $\sqrt{\sum_i (Res_i \cdot ewt_i)^2 } < $ \id{delta}.
    To obtain the \id{N\_Vector} \id{ewt} call \id{CVodeGetErrWeights} 
    (see \S\ref{sss:optout_main}).
  \item[lr]
    is an input flag indicating whether the preconditioner solve
    function is to use the left preconditioner (\id{lr = 1}) or 
    the right preconditioner (\id{lr = 2});
  \item[p\_data]
    is the \id{p\_data}      
    pointer passed to \id{CVSp*SetPreconditioner}.
  \item[tmp]
    is a pointer to memory allocated for a variable of type \id{N\_Vector}
    which can be used for work space.
  \end{args}
}
{
  The value to be returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted). 
}
{}

%%==============================================================================
\subsection{Preconditioning (Jacobian data)}\label{ss:precondFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner setup function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner setup function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied {\C} function of type \Id{CVSpilsPrecSetupFn}, defined as follows:
\usfunction{CVSpilsPrecSetupFn}
{
  typedef int (*CVSpilsPrecSetupFn&)(realtype t, N\_Vector y, N\_Vector fy,  \\
                                  &booleantype jok, booleantype *jcurPtr, \\
                                  &realtype gamma, void *p\_data,\\
                                  &N\_Vector tmp1, N\_Vector tmp2,\\
                                  &N\_Vector tmp3);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner.
}
{
  The arguments of a \id{CVSpilsPrecSetupFn} are as follows:
  \begin{args}[jcurPtr]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, 
    namely the predicted value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.                    
  \item[jok]
    is an input flag indicating whether the Jacobian-related   
    data needs to be updated. The \id{jok} argument provides for 
    the reuse of Jacobian data in the preconditioner solve function.
    \id{jok = FALSE} means that the Jacobian-related data   
    must be recomputed from scratch.                                 
    \id{jok = TRUE}  means that the Jacobian data, if saved from 
    the previous call to this function, can be reused      
    (with the current value of \id{gamma}).            
    A call with \id{jok = TRUE} can only occur after   
    a call with \id{jok = FALSE}.
  \item[jcurPtr]
    is a pointer to a flag which should be
    set to \id{TRUE} if Jacobian data was recomputed, or set
    to \id{FALSE} if Jacobian data was not           
    recomputed, but saved data was still reused.
  \item[gamma]
    is the scalar $\gamma$ appearing in the Newton matrix $M = I - \gamma P$.
  \item[p\_data]
    is the \id{p\_data}      
    pointer passed to \id{CVSp*SetPreconditioner}.
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{CVSpilsPrecSetupFn} as temporary storage or work space.    
  \end{args}
}
{
  The value to be returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted). 
}
{
  The operations performed by this function might include forming a crude 
  approximate Jacobian, and performing an LU factorization of the resulting
  approximation to $M=I - \gamma J$.

  Each call to the preconditioner setup function is preceded by a call to     
  the \id{CVRhsFn} user function with the same \id{(t,y)} arguments.  
  Thus, the preconditioner setup function can use any auxiliary data that is 
  computed and saved during the evaluation of the ODE right-hand side.
  
  This function is not called in advance of every call to the preconditioner
  solve function, but rather is called only as often as needed to achieve
  convergence in the Newton iteration. 

  If the user's \id{CVSpilsPrecSetupFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current step size, the error weights, etc.
  To obtain these, use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed
  as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}

%%
%%===================================================================================
\section{Integration of pure quadrature equations}
%%===================================================================================
%%

If the system of ODEs contains {\em pure quadratures}, it is more efficient
to treat them separately by excluding them from the nonlinear solution stage. 
To do this, begin by excluding the quadrature variables from the vector \id{y}
and the quadrature equations from within \id{f}. The following is an overview of 
the sequence of calls in a user's main program in this situation. Steps that are
unchanged from the skeleton program presented in \S\ref{ss:skeleton_sim} are 
grayed out.

\index{User main program!integration of quadratures}
\begin{Steps}
  
\item 
  \textcolor{gray}{\bf {\p} Initialize MPI}

\item
  {\bf Set problem dimensions}

  {\s} Set \id{N} to the problem size $N$ (excluding quadrature variables),
  and \id{Nq} to the number of quadrature variables.

  {\p} Set \id{Nlocal} to the local vector length (excluding quadrature variables),
  and \id{Nqlocal} to the local number of quadrature variables.
  
\item
  \textcolor{gray}{\bf Set vector of initial values}
 
\item\label{i:quad_cvode_create}
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Attach linear solver module}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item
  {\bf Set vector of initial values for quadrature variables}

  Typically, the quadrature variables should be initialized to $0$.

\item
  {\bf Initialize quadrature integration}

  Call \id{CVodeQuadMalloc} to specify the quadrature equation right-hand
  side function and to allocate internal memory related to quadrature integration. 
  See \S\ref{ss:quad_malloc} for details.

\item\label{i:quad_optional_inputs}
  {\bf Set optional inputs for quadrature integration}

  Call \id{CVodeSetQuadFdata} to specify user data required for the evaluation
  of the quadrature equation right-hand side.
  Call \id{CVodeSetQuadErrCon} to indicate whether or not quadrature variables
  shoule be used in the step size control mechanism, and to specify the integration 
  tolerances for quadrature variables.
  See \S\ref{ss:quad_optional_input} for details.

\item\label{i:quad_cvode_solve}
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Extract quadrature variables}

  Call \id{CVodeGetQuad} to obtain the values of the quadrature variables at
  the current time. See \S\ref{ss:quad_get} for details.

\item
  \textcolor{gray}{\bf Get optional outputs}

\item
  {\bf Get quadrature optional outputs}

  Call \id{CVodeGetQuad*} functions to obtain optional output related to
  the integration of quadratures.
  See \S\ref{ss:quad_optional_output} for details.

\item
  {\bf Deallocate memory for solution vector and for the vector of quadrature variables}
  
\item
  {\bf Free solver memory}

\item 
  \textcolor{gray}{\bf {\p} Finalize MPI}
  
\end{Steps}
%%
\id{CVodeQuadMalloc} can be called and quadrature-related optional inputs 
(step \ref{i:quad_optional_inputs} above) can be set, anywhere between steps 
\ref{i:quad_cvode_create} and \ref{i:quad_cvode_solve}.

%%===================================================================================

\subsection{Quadrature initialization functions}\label{ss:quad_malloc}

The function \id{CVodeQuadMalloc} activates integration of quadrature equations 
and allocates internal memory related to these calculations.
The form of the call to this function is as follows:
%%
\ucfunction{CVodeQuadMalloc}
{
flag = CVodeQuadMalloc(cvode\_mem, fQ, yQ0);
}
{
  The function \Id{CVodeQuadMalloc} provides required problem specifications,
  allocates internal memory, and initializes quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[fQ] (\Id{CVQuadRhsFn})
    is the {\C} function which computes $f_Q$, the right-hand side of the quadrature
    equations. This function has the form 
    \id{fQ(t, y, yQdot, fQ\_data)} (for full details see \S\ref{ss:user_fct_quad}).
  \item[yQ0] (\id{N\_Vector})
    is the initial value of $y_Q$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_MEM\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadMalloc} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory was not initialized by a prior call to \id{CVodeCreate}.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request failed.
  \end{args}
}
{
  If an error occured, \id{CVodeQuadMalloc} also sends an error message to the
  error handler function.
}
%%
\index{memory requirements!CVODES@{\cvodes} solver}
In terms of the number of quadrature variables $N_q$ and maximum method order \id{maxord},
the size of the real workspace is increased by:
\begin{itemize}
\item Base value: \id{lenrw} $=$ \id{lenrw} $+$ (\id{maxord+5})$N_q$
\item With \id{itolQ = CV\_SV} (see \id{CVodeSetQuadErrCon}): \id{lenrw} $=$ \id{lenrw} $+ N_q$ 
\end{itemize}
the size of the integer workspace is increased by:
\begin{itemize}
\item Base value: \id{leniw} $=$ \id{leniw} $+$ (\id{maxord+5})$N_q$
\item With \id{itolQ = CV\_SV}: \id{leniw} $=$ \id{leniw} $+ N_q$ 
\end{itemize}

The function \id{CVodeQuadReInit}, useful during the solution of a sequence of problems of 
same size, reinitializes the quadrature related internal memory 
and must follow a call to \Id{CVodeQuadMalloc} (and maybe a call to \id{CVodeReInit}). 
The number \id{Nq} of quadratures is assumed to be unchanged from the prior call to 
\id{CVodeQuadMalloc}.
The call to the \id{CVodeQuadReInit} function has the form:
%%
\ucfunction{CVodeQuadReInit}
{
  flag = CVodeQuadReInit(cvode\_mem, fQ, yQ0);
}
{
  The function \id{CVodeQuadReInit} provides required problem specifications 
  and reinitializes the quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[fQ] (\Id{CVQuadRhsFn})
    is the {\C} function which computes $f_Q$, the right-hand side of the quadrature
    equations.
  \item[yQ0] (\id{N\_Vector})
    is the initial value of $y_Q$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInit} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory was not initialized by a prior call to \id{CVodeCreate}.
  \item[\Id{CV\_NO\_QUAD}] 
    Memory space for the quadrature integration was not allocated by a prior
    call to \id{CVodeQuadMalloc}.
  \end{args}
}
{
  If an error occured, \id{CVodeQuadReInit} also sends an error message to the
  error handler function.
}
%%

%%===================================================================================

\subsection{CVODE solver function}

Even if quadrature integration was enabled, the call to the main solver 
function \id{CVode} is exactly the same as in \S\ref{sss:cvode}. However, in this
case the return value \id{flag} can also be one of the following:
\begin{args}[CV\_FIRST\_QRHSFUNC\_FAIL]
\item[\Id{CV\_QRHSFUNC\_FAIL}]
  The quadrature right-hand side function failed in an unrecoverable manner.
\item[\Id{CV\_FIRST\_QRHSFUNC\_FAIL}]
  The quadrature right-hand side function failed at the first call.
\item[\Id{CV\_REPTD\_QRHSFUNC\_ERR}]
  Convergence tests occurred too many times due to repeated recoverable errors in
  the quadrature right-hand side function. The \id{CV\_REPTD\_RHSFUNC\_ERR} will also
  be returned if the quadrature right-hand side function had repeated recoverable errors
  during the estimation of an initial step size (assuming the quadrature
  variables are included in the error tests).
\item[\Id{CV\_UNREC\_RHSFUNC\_ERR}]
  The quadrature right-hand function had a recoverable error, but no recovery was possible.
  This failure mode is rare, as it can occur only if the quadrature right-hand side function
  fails recoverably after an error test failed while at order one.
\end{args}

%%===================================================================================

\subsection{Quadrature extraction functions}\label{ss:quad_get}

If quadrature integration has been initialized by a call to \id{CVodeQuadMalloc},
or reinitialized by a call to \id{CVodeQuadReInit}, then {\cvodes} computes both a solution
and quadratures at time \id{t}. However, \id{CVode} will still return only the solution
$y$ in \id{y}. Solution quadratures can be obtained using the following function:
%%
%%
\ucfunction{CVodeGetQuad}
{
  flag = CVodeGetQuad(cvode\_mem, t, yQ);
}
{
  The function \id{CVodeGetQuad} returns the quadrature solution vector after a
  successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[t] (\id{realtype})
    the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    successful step taken by {\cvodes}.
  \item[yQ] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuad} is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetQuad} was successful.
  \item[CV\_MEM\_NULL] 
    \id{cvode\_mem} was NULL.
  \item[CV\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[CV\_BAD\_DKY] 
    \id{yQ} is \id{NULL}.
  \item[CV\_BAD\_T] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also sent to the error handler
  function.
}
%%
%%
\index{optional output!interpolated quadratures}
The function \Id{CVodeGetQuadDky} computes the \id{k}-th derivatives of the interpolating 
polynomials for the quadrature variables at time \id{t}.
This function is called by \id{CVodeGetQuad} with \id{k = 0}, but may also be called 
directly by the user.
%%
\ucfunction{CVodeGetQuadDky}
{
  flag = CVodeGetQuadDky(cvode\_mem, t, k, dkyQ);
}
{
  The function \id{CVodeGetQuadDky} returns derivatives of the quadrature solution 
  vector after a successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[\id{cvode\_mem}] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeMalloc}.
  \item[\id{t}] (\id{realtype})
    the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    successful step taken by {\cvodes}.
  \item[\id{k}] (\id{int}) order of the requested derivative.
  \item[\id{dkyQ}] (\id{N\_Vector})
    the vector containing the derivative. This vector must be allocated by the user. 
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuadDky} is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetQuadDky} succeeded.
  \item[\Id{CV\_MEM\_NULL}]
    The pointer to \id{cvode\_mem} was NULL.
  \item[\Id{CV\_NO\_QUAD}] 
    Quadrature integration was not initialized.
  \item[\Id{CV\_BAD\_DKY}] 
    The vector \id{dkyQ} is \id{NULL}.
  \item[\Id{CV\_BAD\_K}]
    \id{k} is not in the range $0, 1, ..., q_u$.
  \item[\Id{CV\_BAD\_T}] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also sent to the error handler function.
}
%%
%%

%%===================================================================================

\subsection{Optional inputs for quadrature integration}\label{ss:quad_optional_input}
\index{optional input!quadrature integration|(}
{\cvodes} provides the following optional input functions to control the integration
of quadrature equations.
%%
%%
\ucfunction{CVodeSetQuadFdata}
{
  flag = CVodeSetQuadFdata(cvode\_mem, fQ\_data);
}
{
  The function \Id{CVodeSetQuadFdata} specifies the user-defined data block \Id{fQ\_data}
  and attaches it to the main {\cvodes} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[fQ\_data] (\id{void *})
    pointer to the user data.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If \id{fQ\_data} is not specified, a \id{NULL} pointer is
  passed to all user-supplied functions that have it as an argument.
  Note that \id{fQ\_data} can be the same as the
  pointer \id{f\_data} set through \id{CVodeSetFdata}.
}
%%
%%
\ucfunction{CVodeSetQuadErrCon}
{
 flag = CVodeSetQuadErrCon(cvode\_mem, errconQ, itolQ, reltolQ, abstolQ);
}
{
  The function \Id{CVodeSetQuadErrCon} specifies whether or not the
  quadrature variables should be used in the step size control
  mechanism, and if so, specifies the integration tolerances for the
  quadrature variables.  
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[errconQ] (\id{booleantype})
    specifies whether quadrature variables are included (\id{TRUE}) or not
    (\id{FALSE}) in the error control mechanism. If \id{errconQ}$=$\id{FALSE},
    the following three arguments are ignored.
  \item[itolQ] (\id{int}) 
    is either \Id{CV\_SS} or \Id{CV\_SV}, where \Id{itolQ} \id{= CV\_SS} indicates 
    scalar relative error tolerance and scalar absolute error tolerance, 
    while \id{itolQ = CV\_SV} indicates scalar relative error tolerance and 
    vector absolute error tolerance. 
    The latter choice is important when the absolute error tolerance needs to
    be different for each quadrature variable.
  \item[reltolQ] (\id{realtype *})
    \index{tolerances}
    is a pointer to the relative error tolerance.
  \item[abstolQ] (\id{void *})
    is a pointer to the absolute error tolerance.  If \id{itolQ}$=$\id{CV\_SS},
    \id{abstolQ} must be a pointer to a \id{realtype} variable. If
    \id{itolQ} $=$ \id{CV\_SV}, \id{abstolQ} must be an \id{N\_Vector} variable.
  \item
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}] 
    An input argument to \id{CVodeSetQuadErrCon} has an illegal value.
  \end{args}
}
{
  By default, \id{errconQ} is set to \id{FALSE}. 

  {\warn}It is illegal to call \id{CVodeSetQuadErrCon} before a call 
  to \id{CVodeQuadMalloc}.
}
\index{optional input!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{Optional outputs for quadrature integration}\label{ss:quad_optional_output}
\index{optional output!quadrature integration|(}

{\cvodes} provides the following functions that can be used to obtain solver
performance information related to quadrature integration.

\ucfunction{CVodeGetQuadNumRhsEvals}
{
  flag = CVodeGetQuadNumRhsEvals(cvode\_mem, \&nfQevals);
}
{
  The function \Id{CVodeGetQuadNumRhsEvals} returns the 
  number of calls made to the user's quadrature right-hand side function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfQevals] (\id{long int})
    number of calls made to the user's \id{fQ} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetQuadNumErrTestFails}
{
  flag = CVodeGetQuadNumErrTestFails(cvode\_mem, \&nQetfails);
}
{
  The function \Id{CVodeGetQuadNumErrTestFails} returns the
  number of local error test failures due to quadrature variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeGetQuadErrWeights}
{
  flag = CVodeGetQuadErrWeights(cvode\_mem, eQweight);
}
{
  The function \Id{CVodeGetQuadErrWeights} returns the quadrature error weights 
  at the current time.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eQweight] (\id{N\_Vector})
    quadrature error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{eQweight}.

  If quadratures were not included in the error control mechanism (through a 
  call to \id{CVodeSetQuadErrCon} with \id{errconQ = TRUE}), 
  \id{CVodeGetQuadErrWeights} does not set the \id{eQweight} vector.
}
%%
%%
\ucfunction{CVodeGetQuadStats}
{
  flag = CVodeGetQuadStats(cvode\_mem, \&nfQevals, \&nQetfails);
}
{
  The function \Id{CVodeGetQuadStats} returns the {\cvodes} integrator statistics
  as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfQevals] (\id{long int})
    number of calls to the user's \id{fQ} function.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    the optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    the \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
\index{optional output!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{User-supplied function for quadrature integration}
\label{ss:user_fct_quad}

\index{right-hand side function!quadrature equations}
For integration of quadrature equations, the user must provide a function 
that defines the right-hand side of the quadrature equations. This function
must be of type \Id{CVQuadRhsFn} defined as follows:
\usfunction{CVQuadRhsFn}
{
  typedef int (*CVQuadRhsFn)(&realtype t, N\_Vector y, \\
                             &N\_Vector yQdot, void *fQ\_data);
}
{
  This function computes the quadrature equation right-hand side for a given value
  of the independent variable $t$ and state vector $y$.
}
{
  \begin{args}[fQ\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yQdot]
    is the output vector $f_Q(t,y)$.
  \item[fQ\_data]
    is the \Id{fQ\_data}      
    pointer passed to \id{CVodeSetQuadFdata}.   
  \end{args}
}
{
  A \id{CVQuadRhsFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \Id{CV\_QRHSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{yQdot} is automatically handled within {\cvodes}.

  Both \id{y} and \id{yQdot} are of type \id{N\_Vector},
  but they  typically have different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  There are two situations in which recovery is not possible even if \id{CVQuadRhsFn}
  function returns a recoverable error flag. This include the situation when this
  occurrs at the very first call to the \id{CVQuadRhsFn} (in which case {\cvodes} returns
  \Id{CV\_FIRST\_QRHSFUNC\_ERR}) or if a recoverable error is reported when \id{CVQuadRhsFn}
  is called after an error test failure, while the linear multistep method order is
  equal to 1 (in which case {\cvodes} returns \Id{CV\_UNREC\_QRHSFUNC\_ERR}).
}

%%==============================================================================
\section{Rootfinding}\label{s:using_rootfinding}
%%==============================================================================
\index{Rootfinding}

While solving the IVP, {\cvodes} has the capability to find the
roots of a set of user-defined functions. This section describes the
user-callable functions used to initialize and define the rootfinding
problem and to obtain solution information, and it also describes the
required user-supplied function.

%%==============================================================================
\subsection{User-callable functions for rootfinding}\label{ss:root_uc}
%%==============================================================================

\ucfunction{CVodeRootInit}
{
  flag = CVodeRootInit(cvode\_mem, nrtfn, g, g\_data);
}
{
  The function \Id{CVodeRootInit} specifies that the roots of a set of
  functions $g_i(t,y)$ are to be found while the IVP is being solved.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[nrtfn] (\id{int})
    is the number of root functions $g_i$.
  \item[g] (\id{CVRootFn})
    is the {\C} function which defines the \id{nrtfn} functions $g_i(t,y)$
    whose roots are sought. See \S\ref{ss:root_us} for details.
  \item[g\_data] (\id{void *})
    pointer to the user data for use by the user's root function $g$.
 \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[CV\_SUCCESS]
    The call to \id{CVodeRootInit} was successful.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[CV\_MEM\_FAIL]
    A memory allocation failed.
  \item[CV\_ILL\_INPUT]
    The function \id{g} is \id{NULL}, but \id{nrtfn}$>0$.
  \end{args}
}
{
  If a new IVP is to be solved with a call to \id{CVodeReInit}, where the new
  IVP has no rootfinding problem but the prior one did, then call
  \id{CVodeRootInit} with \id{nrtfn}$=0$.
}
%%
%%
There are two optional output functions associated with rootfinding.
%%
%%
\ucfunction{CVodeGetRootInfo}
{
  flag = CVodeGetRootInfo(cvode\_mem, rootsfound);
}
{
  The function \Id{CVodeGetRootInfo} returns an array showing which 
  functions were found to have a root.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[rootsfound] (\id{int *})
    an \id{int} array of length \id{nrtfn} showing the indices
    of the user functions $g_i$ found to have a root.  For
    $i=0,\ldots,$\id{nrtfn}$-1$, \id{rootsfound}[$i$]$=1$ if $g_i$
    has a root, and $0$ if not.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate memory for the vector \id{rootsfound}.  
}
%%
%%
\ucfunction{CVodeGetNumGEvals}
{
  flag = CVodeGetNumGEvals(cvode\_mem, \&ngevals);
}
{
  The function \Id{CVodeGetNumGEvals} returns the cumulative
  number of calls made to the user-supplied root function $g$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ngevals] (\id{long int})
    number of calls made to the user's function \id{g} thus far.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

%%==============================================================================
\subsection{User-supplied function for rootfinding}\label{ss:root_us}
%%==============================================================================

If a rootfinding problem is to be solved during the integration of the ODE system,
the user must supply a {\C} function of type \Id{CVRootFn}, defined as follows:
%%
\usfunction{CVRootFn}
{
  typedef int (*CVRootFn)(&realtype t, N\_Vector y, realtype *gout, \\
                          &void *g\_data);
}
{
  This function implements a vector-valued function $g(t,y)$ such that the roots of 
  the \id{nrtfn} components $g_i(t,y)$ are sought.
}
{
  \begin{args}[g\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[gout]
    is the output array, of length \id{nrtfn}, with components $g_i(t,y)$.
  \item[g\_data]
    is the \Id{g\_data}      
    pointer passed to \id{CVodeRootInit}.   
  \end{args}
}
{
  A \id{CVRootFn} should return 0 if successful or a non-zero value if
  an error occured (in which case the integration is halted and \id{CVode} returns
  \Id{CV\_RTFUNC\_FAIL}).
}
{
  Allocation of memory for \id{gout} is automatically handled within {\cvodes}.
}

%%==============================================================================
\section{Preconditioner modules}\label{ss:preconds}
%%==============================================================================

The efficiency of Krylov iterative methods for the solution of linear systems 
can be greatly enhanced through preconditioning. For problems in which the 
user cannot define a more effective, problem-specific preconditioner,
{\cvodes} provides a banded preconditioner in the module {\cvbandpre} and
a band-block-diagonal preconditioner module {\cvbbdpre}.

%%==============================================================================
\subsection{A serial banded preconditioner module}\label{sss:cvbandpre}
%%==============================================================================

\index{CVBANDPRE@{\cvbandpre} preconditioner!description}
\index{preconditioning!banded}

This preconditioner provides a band matrix preconditioner for use with
any of the Krylov iterative linear solvers, in a serial setting.
It uses difference quotients of the ODE right-hand side function \id{f} to
generate a band matrix of bandwidth $m_l + m_u + 1$, where the number of
super-diagonals ($m_u$, the upper half-bandwidth) and sub-diagonals
($m_l$, the lower half-bandwidth) are specified by the user, and uses this to
form a preconditioner for use with the Krylov linear solver.
Although this matrix is intended to approximate the Jacobian
$\partial f / \partial y$, it may be a very crude approximation.  The true Jacobian
need not be banded, or its true bandwidth may be larger than $m_l + m_u + 1$, as
long as the banded approximation generated here is sufficiently accurate to
speed convergence as a preconditioner. 

\index{CVBANDPRE@{\cvbandpre} preconditioner!usage|(}
In order to use the {\cvbandpre} module, the user need not define any
additional functions. 
%%
Aside from the header files required for the integration of the ODE problem
(see \S\ref{ss:header_sim}),  to use the {\cvbandpre} module, the main program 
must include the header file \id{cvodes\_bandpre.h} which declares the needed
function prototypes.\index{header files}
%%
The following is a summary of the usage of this module. Steps that are unchanged from the skeleton
program presented in \S\ref{ss:skeleton_sim} are grayed out.
%%
%%
\index{User main program!CVBANDPRE@{\cvbandpre} usage}
\begin{Steps}
  
\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Set vector of initial values}
 
\item
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item \label{i:bandpre_init}
  {\bf Initialize the {\cvbandpre} preconditioner module}

  Specify the upper and lower half-bandwidths (\id{mu} and \id{ml}, respectively) and call 

  \id{bp\_data = CVBandPrecAlloc(cvode\_mem, N, mu, ml);} 

  to allocate memory for and to initialize a data structure (pointed to by
  \id{bp\_data}) to be passed to the appropriate \id{CVSp*} linear solver.

\item \label{i:bandpre_attach}
  {\bf Attach the Krylov linear solver, one of:}

  \id{flag = CVBPSpgmr(cvode\_mem, pretype, maxl, bp\_data);}

  \id{flag = CVBPSpbcg(cvode\_mem, pretype, maxl, bp\_data);}

  \id{flag = CVBPSptfqmr(cvode\_mem, pretype, maxl, bp\_data);}

  Each function \id{CVBPSp*} is a wrapper around the corresponding
  specification function \id{CVSp*} and performs the following actions:
  \begin{itemize}
    \item Attaches the {\cvspils} linear solver to the main {\cvodes} solver memory;
    \item Sets the preconditioner data structure for {\cvbandpre};
    \item Sets the preconditioner setup function for {\cvbandpre};
    \item Sets the preconditioner solve function for {\cvbandpre};
  \end{itemize}
  The arguments \id{pretype} and \id{maxl} are described below.
  The last argument of \id{CVBPSp*} is the pointer to the {\cvbandpre} data
  returned by \id{CVBandPrecAlloc}.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

  Note that the user should not overwrite the preconditioner data, setup function, 
  or solve function through calls to \id{CVSp*} optional input functions.

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item \label{i:bandpre_free}
  {\bf Free the {\cvbandpre} data structure}

  \id{CVBandPrecFree(\&bp\_data);}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\end{Steps}
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!usage|)}

\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|(}
The user-callable functions that initialize, attach, and deallocate
the {\cvbandpre} preconditioner module (steps \ref{i:bandpre_init},
\ref{i:bandpre_attach} and \ref{i:bandpre_free} above) are described
in more detail below.
%%
\index{half-bandwidths}
\ucfunction{CVBandPrecAlloc}
{
  bp\_data = CVBandPrecAlloc(cvode\_mem, N, mu, ml);
}
{
  The function \Id{CVBandPrecAlloc} initializes and allocates
  memory for the {\cvbandpre} preconditioner.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \item[mu] (\id{long int})
    upper half-bandwidth of the Jacobian approximation.
  \item[ml] (\id{long int})
    lower half-bandwidth of the Jacobian approximation.
  \end{args}
}
{
  If successful, \id{CVBandPrecAlloc} returns a pointer to the newly created 
  {\cvbandpre} memory block (of type \id{void *}).
  If an error occurred, \id{CVBandPrecAlloc} returns \id{NULL}.
}
{
  The banded approximate Jacobian will have nonzero elements only in locations
  $(i,j)$ with $-$\id{ml} $\leq j-i \leq$ \id{mu}.
}
%%
%%
\ucfunction{CVBPSpgmr}
{
  flag = CVBPSpgmr(cvode\_mem, pretype, maxl, bp\_data);
}
{
  The function \Id{CVBPSpgmr} links the {\cvbandpre} data to the
  {\cvspgmr} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    specifies the preconditioning type and must be either
    \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL = 5}.
  \item[bp\_data] (\id{void *})
    pointer to the {\cvbandpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBANDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspgmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBANDPRE\_PDATA\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVBPSpbcg}
{
  flag = CVBPSpbcg(cvode\_mem, pretype, maxl, bp\_data);
}
{
  The function \Id{CVBPSpbcg} links the {\cvbandpre} data to the
  {\cvspbcg} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    preconditioning type. Must be one of \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \item[bp\_data] (\id{void *})
    pointer to the {\cvbandpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBANDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspbcg} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBANDPRE\_PDATA\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVBPSptfqmr}
{
  flag = CVBPSptfqmr(cvode\_mem, pretype, maxl, bp\_data);
}
{
  The function \Id{CVBPSptfqmr} links the {\cvbandpre} data to the
  {\cvsptfqmr} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    preconditioning type. Must be one of \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \item[bp\_data] (\id{void *})
    pointer to the {\cvbandpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBANDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvsptfqmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBANDPRE\_PDATA\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\ucfunction{CVBandPrecFree}
{
  CVBandPrecFree(\&bp\_data);
}
{
  The function \Id{CVBandPrecFree} frees the pointer allocated by
  \id{CVBandPrecAlloc}.
}
{
  The only argument passed to \id{CVBandPrecFree} is the pointer to the {\cvbandpre} 
  data structure (of type \id{void *}).
}
{
  The function \id{CVBandPrecFree} has no return value.
}
{}
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|)}

\index{optional output!banded preconditioner|(}
\index{CVBANDPRE@{\cvbandpre} preconditioner!optional output|(}

\noindent The following three optional output functions are available for use with 
the {\cvbandpre} module:
%%
%%
\ucfunction{CVBandPrecGetWorkSpace}
{
  flag = CVBandPrecGetWorkSpace(bp\_data, \&lenrwBP, \&leniwBP);
}
{
  The function \Id{CVBandPrecGetWorkSpace} returns the sizes of
  the {\cvbandpre} real and integer workspaces.
}
{
  \begin{args}[lenrwBP]
  \item[bp\_data] (\id{void *})
    pointer to the {\cvbandpre} data structure.
  \item[lenrwBP] (\id{long int})
    the number of \id{realtype} values in the {\cvbandpre} workspace.
  \item[leniwBP] (\id{long int})
    the number of integer values in the {\cvbandpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBANDPRE\_PDATA\_NULL]
  \item[\Id{CVBANDPRE\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CVBANDPRE\_PDATA\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!CVBANDPRE@{\cvbandpre} preconditioner}
  In terms of problem size $N$ and \id{smu} = $\min(N-1,\,$\id{mu+ml}),
  the actual size of the real workspace is
  $(2$ \id{ml} $+$ \id{mu} $+$ \id{smu} $+2)\, N$ \id{realtype} words,
  and the actual size of the integer workspace is $N$ integer words.

  The workspaces referred to here exist in addition to those given by the
  corresponding \id{CVSp***GetWorkSpace} function.
}
%%
%%
\ucfunction{CVBandPrecGetNumRhsEvals}
{
  flag = CVBandPrecGetNumRhsEvals(bp\_data, \&nfevalsBP);
}
{
  The function \Id{CVBandPrecGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function for
  finite difference banded Jacobian approximation used within
  the preconditioner setup function.
}
{
  \begin{args}[nfevalsBP]
  \item[bp\_data] (\id{void *})
    pointer to the {\cvbandpre} data structure.
  \item[nfevalsBP] (\id{long int})
    the number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBANDPRE\_PDATA\_NULL]
  \item[\Id{CVBANDPRE\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVBANDPRE\_PDATA\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{
The counter \id{nfevalsBP} is distinct from the counter \id{nfevalsLS}
returned by the corresponding \id{CVSp***GetNumRhsEvals} function, and
also from \id{nfevals}, returned by \id{CVodeGetNumRhsEvals}.
The total number of right-hand side function evaluations is the
sum of all three of these counters.
}
%%
\ucfunction{CVBandPrecGetReturnFlagName}
{
  name = CVBandPrecGetReturnFlagName(flag);
}
{
  The function \ID{CVBandPrecGetReturnFlagName} returns the
  name of the {\cvbandpre} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvbandpre} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVBANDPRE@{\cvbandpre} preconditioner!optional output|)}
\index{optional output!banded preconditioner|)}

%%==============================================================================
\subsection{A parallel band-block-diagonal preconditioner module}
\label{sss:cvbbdpre}
%%==============================================================================

A principal reason for using a parallel ODE solver such as {\cvodes} lies
in the solution of partial differential equations (PDEs).  Moreover,
the use of a Krylov iterative method for the solution of many such
problems is motivated by the nature of the underlying linear system of
equations (\ref{e:Newton}) that must be solved at each time step.  The
linear algebraic system is large, sparse and structured. However, if
a Krylov iterative method is to be effective in this setting, then a
nontrivial preconditioner needs to be used.  Otherwise, the rate of
convergence of the Krylov iterative method is usually unacceptably
slow.  Unfortunately, an effective preconditioner tends to be
problem-specific.

However, we have developed one type of preconditioner that treats a
rather broad class of PDE-based problems.  It has been successfully
used for several realistic, large-scale problems \cite{HiTa:98} and is
included in a software module within the {\cvodes} package. This module
works with the parallel vector module {\nvecp} and is usable with any of
the Krylov iterative linear solvers.  It generates a preconditioner
that is a block-diagonal matrix with each block being a band matrix.
The blocks need not have the same number of super- and sub-diagonals
and these numbers may vary from block to block. This Band-Block-Diagonal
Preconditioner module is called {\cvbbdpre}.

\index{CVBBDPRE@{\cvbbdpre} preconditioner!description|(}
\index{preconditioning!band-block diagonal}
One way to envision these preconditioners is to think of the domain of
the computational PDE problem as being subdivided into $M$ non-overlapping
subdomains.  Each of these subdomains is then assigned to one of the
$M$ processes to be used to solve the ODE system. The basic idea is
to isolate the preconditioning so that it is local to each process,
and also to use a (possibly cheaper) approximate right-hand side
function. This requires the definition of a new function $g(t,y)$
which approximates the function $f(t, y)$ in the definition of the ODE
system (\ref{e:ivp}). However, the user may set $g = f$.  Corresponding
to the domain decomposition, there is a decomposition of the solution
vector $y$ into $M$ disjoint blocks $y_m$, and a decomposition of $g$
into blocks $g_m$.  The block $g_m$ depends both on $y_m$ and on
components of blocks $y_{m'}$ associated with neighboring subdomains
(so-called ghost-cell data).  Let $\bar{y}_m$ denote $y_m$ augmented
with those other components on which $g_m$ depends.  Then we have
\begin{equation}
  g(t,y) = [g_1(t,\bar{y}_1), g_2(t,\bar{y}_2), \ldots, g_M(t,\bar{y}_M)]^T
\end{equation}
and each of the blocks $g_m(t, \bar{y}_m)$ is uncoupled from the others.

The preconditioner associated with this decomposition has the form 
\begin{equation}
  P= diag[P_1, P_2, \ldots, P_M]
\end{equation}
where 
\begin{equation}
  P_m \approx I - \gamma J_m
\end{equation}
and $J_m$ is a difference quotient approximation to 
$\partial g_m/\partial y_m$. This matrix is taken to be banded, with
upper and lower half-bandwidths \id{mudq} and \id{mldq} defined as
the number of non-zero diagonals above and below the main diagonal,
respectively. The difference quotient approximation is computed using
\id{mudq} $+$ \id{mldq} $+ 2$ evaluations of $g_m$, but only a matrix
of bandwidth \id{mu} $+$ \id{ml} $+ 1$ is retained. 
Neither pair of parameters need be the true half-bandwidths of the Jacobian of the
local block of $g$, if smaller values provide a more efficient
preconditioner. The solution of the complete linear system
\begin{equation}
  Px = b
\end{equation}
reduces to solving each of the equations 
\begin{equation}
  P_m x_m = b_m
\end{equation}
and this is done by banded LU factorization of $P_m$ followed by a banded
backsolve.
\index{CVBBDPRE@{\cvbbdpre} preconditioner!description|)}

Similar block-diagonal preconditioners could be considered with different
treatments of the blocks $P_m$. For example, incomplete LU factorization or
an iterative method could be used instead of banded LU factorization.

\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|(}
The {\cvbbdpre} module calls two user-provided functions to construct $P$: 
a required function \id{gloc} (of type \id{CVLocalFn}) which approximates
the right-hand side function $g(t,y) \approx f(t,y)$ and which is computed locally,
and an optional function \id{cfn} (of type \id{CVCommFn}) which performs 
all interprocess communication necessary to evaluate the approximate right-hand
side $g$.  These are in addition to the user-supplied right-hand side function
\id{f}.  Both functions take as input the same pointer \id{f\_data} that is passed
by the user to \id{CVodeSetFdata} and that was passed to the user's function \id{f},
and neither function has a return value. The user is responsible for
providing space (presumably within \id{f\_data}) for components of \id{y}
that are communicated between processes by \id{cfn}, and that are
then used by \id{gloc}, which is not expected to do any communication.
%%
%%
\usfunction{CVLocalFn}
{
  typedef int (*CVLocalFn)(&long int Nlocal, realtype t, N\_Vector y, \\
                           &N\_Vector glocal, void *f\_data);
}
{
  This function computes $g(t,y)$. It loads the vector
  \id{glocal} as a function of \id{t} and \id{y}.  
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the dependent variable. 
  \item[glocal]
    is the output vector.
  \item[f\_data]
    is the \Id{f\_data}      
    pointer passed to \id{CVodeSetFdata}.  
  \end{args}
}
{
  A \id{CVLocalFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVode} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  This function assumes that all interprocess communication of data needed to 
  calculate \id{glocal} has already been done, and that this data is accessible within
  \id{f\_data}.

  The case where $g$ is mathematically identical to $f$ is allowed.
}
%%
%%
\usfunction{CVCommFn}
{
  typedef int (*CVCommFn)(&long int Nlocal, realtype t,  \\
                          &N\_Vector y, void *f\_data);
}
{
  This function performs all interprocess communication necessary 
  for the execution of the \id{gloc} function above, using the input vector \id{y}.
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the dependent variable. 
  \item[f\_data]
    is the \Id{f\_data}      
    pointer passed to \id{CVodeSetFdata}.  
  \end{args}
}
{
  A \id{CVCommFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVode} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  The \id{cfn} function is expected to save communicated data in space defined
  within the data structure \id{f\_data}. 

  Each call to the \id{cfn} function is preceded by a call to the right-hand side
  function \id{f} with the same (\id{t}, \id{y}) arguments.  Thus, \id{cfn} can omit 
  any communication done by \id{f} if relevant to the evaluation of \id{glocal}.  
  If all necessary comunication was done in \id{f}, then \id{cfn = NULL}
  can be passed in the call to \id{CVBBDPrecAlloc} (see below).
}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|)}

\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage|(}
%%
Besides the header files required for the integration of the ODE problem
(see \S\ref{ss:header_sim}),  to use the {\cvbbdpre} module, the main program 
must include the header file \id{cvodes\_bbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the proper usage of this module. Steps that are
unchanged from the skeleton program presented in \S\ref{ss:skeleton_sim} are grayed out.
%%
%%
\index{User main program!CVBBDPRE@{\cvbbdpre} usage}
\begin{Steps}
\item 
  \textcolor{gray}{\bf Initialize MPI}

\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Set vector of initial values}
 
\item
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item \label{i:bbdpre_init}
  {\bf Initialize the {\cvbbdpre} preconditioner module}

  Specify the upper and lower half-bandwidths \id{mudq} and \id{mldq}, and
  \id{mukeep} and \id{mlkeep}, and call 

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       bbd\_data = CVBBDPrecAlloc(&cvode\_mem, local\_N, mudq, mldq, \\
                                  &mukeep, mlkeep, dqrely, gloc, cfn);
     \end{tabular}
   }

  to allocate memory for and to initialize a data structure \id{bbd\_data}
  (of type \id{void *}) to be passed to the Krylov linear solver selected
  (in the next step).  The last two arguments passed to \id{CVBBDPrecAlloc}
  are the two user-supplied functions described above.

\item \label{i:bbdpre_attach}
  {\bf Attach the Krylov linear solver, one of:}

  \id{flag = CVBBDSpgmr(cvode\_mem, pretype, maxl, bbd\_data);}

  \id{flag = CVBBDSpbcg(cvode\_mem, pretype, maxl, bbd\_data);}

  \id{flag = CVBBDSptfqmr(cvode\_mem, pretype, maxl, bbd\_data);}

  The function \id{CVBPSp*} is a wrapper around the corresponding specification
  function \id{CVSp*} and performs the following actions:
  \begin{itemize}
    \item Attaches the {\cvspils} linear solver to the main {\cvodes} solver memory;
    \item Sets the preconditioner data structure for {\cvbbdpre};
    \item Sets the preconditioner setup function for {\cvbbdpre};
    \item Sets the preconditioner solve function for {\cvbbdpre};
  \end{itemize}
  The arguments \id{pretype} and \id{maxl} are described below.
  The last argument of \id{CVBBDSp*} is the pointer to the {\cvbbdpre} data
  returned by \id{CVBBDPrecAlloc}.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

  Note that the user should not overwrite the preconditioner data, setup function, 
  or solve function through calls to {\cvspils} optional input functions.

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item \label{i:bbdpre_free}
  {\bf Free the {\cvbbdpre} data structure}

  \id{CVBBDPrecFree(\&bbd\_data);}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\item 
  \textcolor{gray}{\bf Finalize MPI}

\end{Steps}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage|)}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|(}
%%
The user-callable functions that initialize, attach, and deallocate
the {\cvbbdpre} preconditioner module (steps \ref{i:bbdpre_init},
\ref{i:bbdpre_attach}, and \ref{i:bbdpre_free} above) are described
next.
%%
\index{half-bandwidths}
\ucfunction{CVBBDPrecAlloc}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     bbd\_data = CVBBDPrecAlloc(&cvode\_mem, local\_N, mudq, mldq, \\
                                &mukeep, mlkeep, dqrely, gloc, cfn);
   \end{tabular}
}
{
  The function \Id{CVBBDPrecAlloc} initializes and allocates
  memory for the {\cvbbdpre} preconditioner.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[local\_N] (\id{long int})
    local vector length.
  \item[mudq] (\id{long int})
    upper half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mldq] (\id{long int})
    lower half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mukeep] (\id{long int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeep] (\id{long int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrely] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  The default is \id{dqrely}$ = \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dqrely = 0.0}.
  \item[gloc] (\id{CVLocalFn})
    the {\C} function which computes the approximation $g(t,y) \approx f(t,y)$. 
  \item[cfn] (\id{CVCommFn})
    the optional {\C} function which performs all interprocess communication
    required for the computation of $g(t,y)$.
  \end{args}
}
{
  If successful, \id{CVBBDPrecAlloc} returns a pointer to the newly created 
  {\cvbbdpre} memory block (of type \id{void *}).
  If an error occurred, \id{CVBBDPrecAlloc} returns \id{NULL}.
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} to be used in the 
  difference quotient calculation of the approximate Jacobian is negative or 
  exceeds the value \id{local\_N}$-1$, it is replaced with 0 or
  \id{local\_N}$-1$ accordingly.

  The half-bandwidths \id{mudq} and \id{mldq} need not be the true 
  half-bandwidths of the Jacobian of the local block of $g$    
  when smaller values may provide a greater efficiency.       

  Also, the half-bandwidths \id{mukeep} and \id{mlkeep} of the retained 
  banded approximate Jacobian block may be even smaller,      
  to reduce storage and computational costs further.            

  For all four half-bandwidths, the values need not be the    
  same for every process.
}
%%
%%
\ucfunction{CVBBDSpgmr}
{
  flag = CVBBDSpgmr(cvode\_mem, pretype, maxl, bbd\_data);
}
{
  The function \Id{CVBBDSpgmr} links the {\cvbbdpre} data to the
  {\cvspgmr} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    preconditioning type. Must be either \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL = 5}.
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspgmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVBBDSpbcg}
{
  flag = CVBBDSpbcg(cvode\_mem, pretype, maxl, bbd\_data);
}
{
  The function \Id{CVBBDSpbcg} links the {\cvbbdpre} data to the
  {\cvspbcg} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    preconditioning type. Must be one of \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvspbcg} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{CVBBDSptfqmr}
{
  flag = CVBBDSptfqmr(cvode\_mem, pretype, maxl, bbd\_data);
}
{
  The function \Id{CVBBDSptfqmr} links the {\cvbbdpre} data to the
  {\cvsptfqmr} linear solver and attaches the latter to the {\cvodes}
  memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[pretype] (\id{int})
    \index{pretype@\texttt{pretype}}
    preconditioning type. Must be one of \Id{PREC\_LEFT} or \Id{PREC\_RIGHT}.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{CVSPILS\_MAXL} $= 5$.
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The {\cvsptfqmr} initialization was successful.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The preconditioner type \id{pretype} is not valid.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\ucfunction{CVBBDPrecFree}
{
  CVBBDPrecFree(\&bbd\_data);
}
{
  The function \Id{CVBBDPrecFree} frees the memory allocated by
  \id{CVBBDPrecAlloc}.
}
{
  The only argument passed to \id{CVBBDPrecFree} is the address of the pointer
  to the {\cvbbdpre} data structure (of type \id{void *}).
}
{
  The function \id{CVBBDPrecFree} has no return value.
}
{}

The {\cvbbdpre} module also provides a reinitialization function to allow
solving a sequence of problems of the same size, with the same linear solver
choice, provided there is no change in \id{local\_N}, \id{mukeep}, or \id{mlkeep}.
After solving one problem, and after calling \id{CVodeReInit} to
re-initialize {\cvodes} for a subsequent problem, a call to \id{CVBBDPrecReInit}
can be made to change any of the following: the half-bandwidths \id{mudq} and
\id{mldq} used in the difference-quotient Jacobian approximations, the relative
increment \id{dqrely}, or one of the user-supplied functions \id{gloc} and \id{cfn}.
If there is a change in any of the linear solver inputs, an additional call
to \id{CVSpgmr}, \id{CVSpbcg}, or \id{CVSptfqmr}, and/or one or more of
the corresponding \id{CVSp***Set***} functions, must also be made.

\ucfunction{CVBBDPrecReInit}
{
  flag = CVBBDPrecReInit(bbd\_data, mudq, mldq, dqrely, gloc, cfn);
}
{
  The function \Id{CVBBDPrecReInit} re-initializes the {\cvbbdpre} preconditioner.
}
{
  \begin{args}[bbd\_data]
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \item[mudq] (\id{long int})
    upper half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mldq] (\id{long int})
    lower half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[dqrely] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  The default is \id{dqrely} $= \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dqrely = 0.0}.
  \item[gloc] (\id{CVLocalFn})
    the {\C} function which computes the approximation $g(t,y) \approx f(t,y)$. 
  \item[cfn] (\id{CVCommFn})
    the optional {\C} function which performs all interprocess communication required for
    the computation of $g(t,y)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVBBDPRE\_SUCCESS}] 
    The {\cvspbcg} re-initialization was successful.
    \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} is negative or
  exceeds the value \id{local\_N}$-1$, it is replaced with 0 or
  \id{local\_N}$-1$ accordingly.
}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|)}
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\cvbbdpre} module:
%%
\ucfunction{CVBBDPrecGetWorkSpace}
{
  flag = CVBBDPrecGetWorkSpace(bbd\_data, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \Id{CVBBDPrecGetWorkSpace} returns the local
  {\cvbbdpre} real and integer workspace sizes.
}
{
  \begin{args}[lenrwBBDP]
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \item[lenrwBBDP] (\id{long int})
    local number of \id{realtype} values in the {\cvbbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\cvbbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVBBDPRE\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!CVBBDPRE@{\cvbbdpre} preconditioner}
  In terms of \id{local\_N} and
  \id{smu} = $\min$(\id{local\_N - 1, mukeep} $+$ \id{mlkeep}),
  the actual size of the real workspace is
  (2 \id{mlkeep} $+$ \id{mukeep} $+$ \id{smu} $+2) \, $\id{local\_N}
  \id{realtype} words, and the actual size of the integer workspace is
  \id{local\_N} integer words.  These values are local to each process.

  The workspaces referred to here exist in addition to those given by the
  corresponding \id{CVSp***GetWorkSpace} function.
}
%%
%%
\ucfunction{CVBBDPrecGetNumGfnEvals}
{
  flag = CVBBDPrecGetNumGfnEvals(bbd\_data, \&ngevalsBBDP);
}
{
  The function \Id{CVBBDPrecGetNumGfnEvals} returns the
  number of calls made to the user-supplied \id{gloc} function due to the 
  finite difference approximation of the Jacobian blocks used within
  the preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[bbd\_data] (\id{void *})
    pointer to the {\cvbbdpre} data structure.
  \item[ngevalsBBDP] (\id{long int})
    the number of calls made to the user-supplied \id{gloc} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVBBDPRE\_PDATA\_NULL]
  \item[\Id{CVBBDPRE\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{CVBBDPRE\_PDATA\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\ucfunction{CVBBDPrecGetReturnFlagName}
{
  name = CVBBDPrecGetReturnFlagName(flag);
}
{
  The function \ID{CVBBDPrecGetReturnFlagName} returns the
  name of the {\cvbbdpre} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int} is a return flag from a {\cvbbdpre} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}

In addition to the \id{ngevalsBBDP} \id{gloc} evaluations,
the costs associated with {\cvbbdpre} also include \id{nlinsetups} LU
factorizations, \id{nlinsetups} calls to \id{cfn}, \id{npsolves} banded
backsolve calls, and \id{nfevalsLS} right-hand side function evaluations,
where \id{nlinsetups} is an optional {\cvodes} output and \id{npsolves} and 
\id{nfevalsLS} are linear solver optional outputs (see \S\ref{ss:optional_output}).
