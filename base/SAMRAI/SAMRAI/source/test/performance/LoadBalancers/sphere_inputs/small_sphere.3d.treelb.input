/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright 
 * information, see COPYRIGHT and COPYING.LESSER. 
 *
 * Copyright:     (c) 1997-2012 Lawrence Livermore National Security, LLC
 * Description:   Performance input file for TreeLoadBalancer 
 *
 ************************************************************************/



Main {
   dim = 3

   base_name = "small_sphere.3d.treelb"
   log_all_nodes = FALSE

   // Balancer types: TreeLoadBalancer, ChopAndPackLoadBalancer
   load_balancer_type = "TreeLoadBalancer"

   /*
     Specify domain as a box array in the reference index space.
   */
   domain_boxes = [(0,0,0),(99,99,99)]

   /*
     Specify L0 layer as a box array in the reference index space.
     The L0 layer will be partitioned but its partitioning is not
     used in the performance test.

     If omitted, the L0 layer is the same as the domain.
   */
   L0_boxes = [(0,0,0),(99,99,99)]
   /*
     If L0 is not contained in domain, you can use this flag
     to remove the parts that are outside the domain.
   */
   autonest_L0 = TRUE

   /*
     Specify ghost-cell-width between L0 and unbalanced.
   */
   ghost_cell_width = 4, 4, 4

   L1_box_gen_method = "PrebalanceByUserShells"

   PrebalanceByUserBoxes {
      /*
        Specify unbalanced layer as a box array in the reference index space.

        initial_owners are the ranks of the owners of all the initial balance boxes.
        By default, processor 0 owns all the initial balance boxes.
      */
      prebalance_boxes = [(10,10,10),(89,89,89)]
      initial_owners = 0
      max_box_size = -1, -1, -1
   }

   PrebalanceByUserShells {
      /*
        Specify unbalanced layer by tagging a set of concentric shells,
        centered at r0, with shell i having inner radius 2*i
        and outer radius (2*i)+1.  Note that making shells too thin
        can lead to discontinuous tagging.
      */
      r0 = 0.0, 0.0, 0.0
      radii = 0.0, 0.5, 0.7, 0.8, 1.4, 1.41
      efficiency_tol = 0.85
      combine_tol = 0.85
   }

   PrebalanceByShrinkingLevel {
      shrink_width = 10, 10
      BergerRigoutsos {
         sort_output_nodes = TRUE
         log_node_history = FALSE
         log_cluster_summary = TRUE
         log_cluster = FALSE
         sequentialize_output_indices = FALSE
         barrier_before_cluster = FALSE
         // owner_mode = "SINGLE_OWNER"
         // algo_advance_mode = "SYNCHRONOUS"
      }
   }

}

TreeLoadBalancer {
  report_load_balance = FALSE // Reported in main
  n_root_cycles = -1
  min_load_fraction_per_box = 0.03
  balance_penalty_wt = 1.0
  surface_penalty_wt = 1.0
  slender_penalty_wt = 1.0
  precut_penalty_wt = 1.0

  // Debugging options
  check_map = FALSE
  check_connectivity = FALSE
  print_steps = FALSE
  print_swap_steps = FALSE
  print_break_steps = FALSE
  print_edge_steps = FALSE
}

TimerManager {
//   print_exclusive      = TRUE
   print_summed           = TRUE
   print_max              = TRUE
   print_threshold        = 0.
   timer_list             = "hier::*::*", "mesh::*::*", "apps::*::*"
}


PatchHierarchy {

   /*
     Specify number of levels (1, 2 or 3 for this test).
   */
   max_levels = 2

   enforce_proper_nesting = FALSE
   extend_to_domain_boundary = FALSE
   check_nonrefined_tags = "IGNORE"
   // load_balance = FALSE
   largest_patch_size {
      level_0 = -1,-1,-1
      // level_0 = 20,20,20
      // all finer levels will use same values as level_0...
   }
   smallest_patch_size {
      level_0 = 5,5,5
      // all finer levels will use same values as level_0...
   }
   ratio_to_coarser {
      level_1            = 3, 3, 3
      level_2            = 3, 3, 3
      level_3            = 2, 2, 2
      //  etc.
   }

   allow_patches_smaller_than_ghostwidth = TRUE
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
   proper_nesting_buffer = 1, 1, 1
}
